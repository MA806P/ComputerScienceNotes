
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 nums1 和 nums2 不会同时为空。

示例 1:
nums1 = [1, 3]
nums2 = [2]
则中位数是 2.0

示例 2:
nums1 = [1, 2]
nums2 = [3, 4]
则中位数是 (2 + 3)/2 = 2.5




1、简单粗暴，合并两个数组，求中位数。时间复杂度 O(m+n)
2、也不用合并，只要找到中间那个数就可以，这个和上面的差不多，相当于少遍历了一半。

3、要想时间复杂度为 O(log(m + n)) 就要使用二分法，每次排除 1/2
// 递归，找到两个数组中，第 k 小的那个数
// 当想在两个有序数组中，找到第 k 小的那个数。
// 分别在数组中排除前 k/2 个元素。
// 因为第 k 小的那个数，要么在第1个数组的前k/2中，要么在第2个数组的前k/2中。
// 分别比较 1 2 数组中第 k/2 这个数的大小，小的那个数组前 k/2 个元素就可以排除了，
// 因为 假设小的那个数组前 k/2 个元素中要是有第k小的数，那么一个index < k/2 + k/2 不可能等于 k，所以可以排除。
// 排除了 k/2 之后，然后就是要找新的小数组和原来那个较大值的那个数组中，第 k - k/2 小的那个数，
// 如此下去，直到排除到，k - k/2 == 1 就是两个数组中第一个数小的那个值。




4、中位数，就是集合中一个数，可将集合划分为相等的上下两部分。
//将两数组划分两半

//偶数：i + j = m - i + n - j  ===>  j = (m + n)/2 - i
//如果两数组总长度为偶数，可保证划分后前后长度相等，这时中位数=(左半部分最大值+右半部分最小值)/2
//奇数：i + j = m - i + n - j + 1  ===>  j = (m + n + 1)/2 - i
//如果数组总长度为奇数，划分后左半部分比右半部分多一个数，这时中位数=左半部分最大值

//无论奇偶，都可用 j = (m + n + 1)/2 - i，m+n是偶数 整数/2取整，+1值一样。
//0<=i<=m，j = (m + n + 1)/2 - i 为了保证 0<=j<=n，则必须保证 m<=n

//划分好之后就是要判断是否满足条件。两个数组根据 i 确定 j 的位置划分，确保划分的左右个数相等
//且满足条件 max(A [i - 1] , B [j - 1]) <= min(A[i] , B[j]）
// 只需要保证 B[j - 1] < = A[i] 和 A [i - 1] <= B[j]
//还要考虑边界条件

//所以最后要解决的问题就是找到满足条件的 i，用二分法确定 i
//i 从中间位置开始，然后减半找中间的，直到找到


