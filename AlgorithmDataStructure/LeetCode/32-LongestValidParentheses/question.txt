给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

示例 1:
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"


示例 2:
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"


注意连续最长有效括号，中间有不符合的，会重新计算






动态规划方法
计算 dp[i]，以(结尾的，最后一个dp[i]一定为0。所有只要考虑结尾是)的情况，这时有两种情况
1、...()，s[i-1]=( s[i]=)
dp[i] = dp[i-2] + 2。 这两个括号前面已有的长度 + 当前有效括号长度2
2、...))
dp[i] = dp[i-1] + dp[i - dp[i-1] - 2] + 2。前面的）+ 这两个))匹配的前面的((前面的dp.
画个图 举个例子 就理解了
 0 1 2 3 4 5 6 7 8  9
（ )（ （ ( ) ) ) )  )
 0 2 0 0 0 2 4 8 0  0
dp[5] = dp[4]+dp[5-0-2]+2 = 0 + 0 + 2 = 2  s[5-0-1]==(
dp[6] = dp[5]+dp[6-2-2]+2 = 2 + 0 + 2 = 4  s[6-2-1]==(
dp[7] = dp[6]+dp[7-4-2]+2 = 4 + 2 + 2 = 8  s[7-4-1]==(
dp[8] = 8-dp[7]==0  = 0 s[8-8-1]不符合条件
dp[9] = 9-dp[8]==9  = 0 s[9-0-1]==)不符合条件
时间复杂度O(n) 空间复杂度O(n)


栈
首先将-1放入栈顶，遇到‘(’将下标入栈，遇到‘)’弹出栈顶元素，并将当前元素下标与栈顶的相减，得出当前有效长度，记录下最大值
0 1 2 3 4 5 6 7 8 9 10 11
( )（（  ( ) ) ) ) ) (  )
0( => -1 0
1) => -1 0 pop(0) peek=-1  1-(-1)=2  maxL=2
2( => -1 2
3( => -1 2 3
4( => -1 2 3 4
5) => -1 2 3 4  pop(4) peek=3  5-3=2    maxL=2
6) => -1 2 3    pop(3) peek=2  6-2=4    maxL=4
7) => -1 2      pop(2) peek=-1 7-(-1)=8 maxL=8
8) => -1        pop(-1)  empty push(8)
9) => 8         pop(8)  empty push(9)
10(=> 9 10
11)=> 9 10      pop(10) peek=9 11-9=2  maxL=8
时间复杂度O(n) 空间复杂度O(n)




左右遍历
两个计数器left=(的数，right=)的数，当 left=right 当前有效长度=left*2，如果left<right,都置为0。从左到右left<right = 0，从右到左 left>right = 0，遍历遍历两次，找到最大值
      0 1 2 3 4 5 6 7 8  9  10 11
      ( )（（  ( ) ) ) )  )  (  )
left  1 1 2 3 4 4 4 4 4  0  1  1 
right 0 1 1 1 1 2 3 4 5  10 0  1
max     2           8          2
从右到左
left  5 4 4 3 2 1 1 1 1  1  1  0 
right 7 7 6 6 6 6 5 4 3  2  1  1
max 			    2
时间复杂度O(n) 空间复杂度O(n)
