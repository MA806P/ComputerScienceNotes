31、下一个排列

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1


题干的意思是：
找出这个数组排序出的所有数中，刚好比当前数大的那个数
比如当前 nums = [1,2,3]。这个数是123，找出1，2，3这3个数字排序可能的所有数，
排序后，比123大的那个数 也就是132
123 132 213 231 312 321

如果当前 nums = [3,2,1]。这就是1，2，3所有排序中最大的那个数，
那么就返回1，2，3排序后所有数中最小的那个，也就是1，2，3 -> [1,2,3]







解法：
从右找到第一对两个连续的数字 a[i] 和 a[i-1]，它们满足 a[i]>a[i-1]
如果遍历完了都满足 a[i]>a[i-1] 说明这个是最大的数，是降序排列的数组，需要排列数组为升序的

1 8 4 7 6 5 3 1
7位分界点，7后面的是降序的，从7后面找比7前面以为4大的，也就是5，交换 4 5, 然后将7及以后的升序改为升序就得到了结果
1 8 5 1 3 4 6 7
a[i-1] = 4
a[i] = 7
a[j] = 5
想要创建比当前更大的排列。需要将数字 a[i-1] 替换为位于其右侧区域的数字中比它更大的数字 a[j]。
然后，通过仅使用 a[i-1] 右边的数字来形成最小的排列。 因此，我们需要放置那些按升序排列的数字，以获得最小的排列。




