 




动态规划：
从 n-1 得到 n 的解
题目：
22(括号生成)  
53(最大子序和) 
32(最长有效括号) 
121(买卖股票的最佳时机) 
322(零钱兑换) 
70(爬楼梯)
300(最长上升子序列)
A1716(按摩师,时长)
72(编辑距离 困难-不容易理解)



搜索算法，一般是在“树”或“图”的结构上的，深度优先遍历，广度优先遍历
在“树”上的深度优先遍历，就是回溯算法。在“图”上的深度优先遍历，是 flood fill 算法。深搜比较节约空间。

回溯算法：是一种通过探索所有可能的候选解来找出所有的解的算法。递归实现。
回溯，类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。
题目：22(括号生成)  39 40(组合总和) 46(全排列)


广度优先搜索 
就是从起点出发，每次都尝试访问同一层的节点，如果同一层都访问完了，再访问下一层，一层一层像水波纹一样扩散，路径最短。
最后广度优先搜索找到的路径就是从起点开始的最短合法路径。
树的BFS，把root入队，然后一层层的遍历；
图的BFS，图可以有多个源点，需要标志是否访问过了，防止多次访问；
题目：994(腐烂的橘子)  695(岛屿最大面积)  365(水壶问题)  1162(地图分析)多源广度优先搜索

深度优先搜索
题目：695(岛屿最大面积)  


字典树
题目：208(实现Trie前缀树) 820(单词的压缩编码)



分治法解决问题的模板：
1、定义基本情况。
2、将问题分解为子问题并递归地解决它们。
3、合并子问题的解以获得原始问题的解。


贪心算法：
捡到西瓜，丢了芝麻。就是贪心，贪最大的，小的放弃扔了。
题目：
53(最大子序和)
300(最长上升子序列)


Boyer-Moore 投票算法. 
169(多数元素) 把众数记为 +1，其他数记为 -1，全部加起来和 > 0


自动机
8(字符串转换整数 atoi)这个有意思




二分
二分查找
33(搜素旋转排序数组) 
34(在排序数组中查找元素的第一个和最后一个位置) 
69(x的平方根)
300(最长上升子序列)

二分递归、合并
23(合并K个排序链表)





经典题目：
53(最大子序和)
300(最长上升子序列)
A40(最小的k个数) TOP K 问题


分类：
1、数组中找和 = target。
	1-数组中找两个元素和
	15-数组中找三个元素和  16-三个元素和最接近 target
	18-数组中找四个元素和
	39 40 - 数组中找到和为target的所有组合
	1013. 将数组分成和相等的三个部分
	A57 - II. 和为s的连续正数序列


2、合并多个有序数组、链表
	21-合并两个有序链表
	23-合并K个有序链表
	A1001-合并有序的数组
	876. 链表的中间结点


3、链表反转
	206-反转链表
	24-两两交换链表中的节点 两个一组翻转
	25-K 个一组翻转链表


4、所有组合
	22(括号生成)
	46 47(全排列)

5、最优解
	53(最大子序和)
	121(买卖股票的最佳时机)

6、网格相关
	48(旋转图像)
	54(螺旋矩阵)
	994(腐烂的橘子)
	695(岛屿最大面积)
	892(三维形体的表面积)
	999(车的可用捕获量)
	1162(地图分析)
	289(生命游戏)

7、括号相关
	20(有效的括号)
	22(括号生成)
	32(最长有效括号) 
	1111(有效括号的嵌套深度)


7、26个字母计算次数
	1160(拼写单词)
	409(字母最长回文串)

8、树-数据结构，递归 迭代
	100(相同的树)
	101(对称二叉树)
	104(二叉树的最大深度)
	543(二叉树的直径)
	208(实现Trie前缀树) 
	820(单词的压缩编码)






//--------------- c --------------- 

//--- 链表 ---
struct ListNode {
    int val;
    struct ListNode *next;
};

void dump(struct ListNode *head) {
    if (head == NULL) { printf("list null! \n"); }
    struct ListNode *node = head;
    while (node != NULL) {
        printf("%d -> ", node->val);
        node = node -> next;
    }
    printf("\n");
}
 struct ListNode l1 = {1, NULL};
 struct ListNode l2 = {2, &l1};
 struct ListNode l3 = {3, &l2};
 struct ListNode l4 = {4, &l3};
 dump(&l3);




//--- 栈 ---
typedef int  DATATYPE;
typedef struct _list_stack {
    DATATYPE data;
    int count;
    struct _list_stack *next;
} stack;
stack *stackCreate() {
    stack *s = (stack *)malloc(sizeof(stack));
    if (s == NULL) { return NULL; }
    s->next = NULL;
    s->count = 0;
    return s;
}
void stackDestroy(stack *s) {
    stack *tempS = NULL;
    while (s->next != NULL) {
        tempS = s->next;
        s->next = tempS->next;
        free(tempS);
    }
    free(s);
}
void stackPush(stack *s, DATATYPE data) {
    stack *node = (stack *)malloc(sizeof(stack));
    if (node == NULL) { return; }
    s->count += 1;
    node->data = data;
    node->count = s->count;
    node->next = s->next;
    s->next = node;
}
DATATYPE stackPop(stack *s) {
    if (s->next == NULL) { return 0; }
    stack *next = s->next;
    DATATYPE data = next->data;
    s->count -= 1;
    s->next = next->next;
    free(next);
    return data;
}
void stackDump(stack *s) {
    if (s->next == NULL) { printf("stack empty!\n"); return; }
    stack *next = s->next;
    while (next != NULL) {
        printf("-> %d ", next->data);
        next = next->next;
    }
    printf("\n");
}


/*
//--- 栈 ---
struct stack_node {
    int data;
    struct stack_node *next;
};
typedef struct {
    struct stack_node *next;
} MyStack;
MyStack* myStackCreate() {
    MyStack *stack = (MyStack *)malloc(sizeof(MyStack));
    if (stack == NULL) { return NULL; }
    stack->next = NULL;
    return stack;
}
void myStackPush(MyStack* obj, int x) {
    if (obj == NULL) { return; }
    struct stack_node *node = (struct stack_node*)malloc(sizeof(struct stack_node));
    if (node == NULL) { return; }
    node->data = x;
    node->next = obj->next;
    obj->next = node;
}
int myStackPop(MyStack* obj) {
    if (obj == NULL || obj->next == NULL) { return -1; }
    struct stack_node *node = obj->next;
    obj->next = node->next;
    int data = node->data;
    free(node);
    return data;
}
int myStackTop(MyStack* obj) {
    if (obj == NULL || obj->next == NULL) {return -1; }
    return obj->next->data;
}
bool myStackEmpty(MyStack* obj) {
    if (obj == NULL) { return true; }
    return obj->next == NULL;
}

void myStackFree(MyStack* obj) {
    if (obj == NULL) { return; }
    while (obj->next != NULL) { myStackPop(obj); }
    free(obj);
}
*/






//--------------- 排序 --------------- 

//快速排序
//选择一元素(一般是最后一个)作为分界点，分界点前比它小，后面都是比它大的
//然后子分区继续这样分，直到最后只有一个元素
void swap_item(int *a, int *b) { int temp = *a; *a = *b; *b = temp; }
int partition(int *array, int p, int r) {
    int i = p;
    for (int j = p; j < r; j++) {
	//这里把大于 r 位的数，换到后面，小的换到前面
	//保证了，i 位前的都小于 r，i 位是第一个大于 r 的，遍历完 i r 互换
        if (array[j] < array[r]) {
            if (i != j) { swap_item(array + i, array + j); }
            i++;
        }
    }
    swap_item(array + i, array + r);
    return i;
}
void quick_sort(int *array, int p, int r) {
    if (p >= r) { return; }
    int q = partition(array, p, r);
    quick_sort(array, p, q - 1);
    quick_sort(array, q + 1, r);
}




//从某个位置翻转数组
void reverse(int *nums, int numsSize, int start) {
    int i = start, j = numsSize - 1;
    while (i < j) {
        swap(nums, i, j);
        i++; j--;
    }
}




//辗转相除法，求最大公因子
int m_gcd(int a, int b) {
    //printf("%d %d\n", a, b);
    return b == 0 ? a : m_gcd(b, a % b);
}







//--------------- swift --------------- 

extension StringProtocol {
    func indexDistance<S: StringProtocol>(of string: S) -> Int? { range(of: string)?.lowerBound.distance(in: self) }
}
extension Collection {
    func distance(to index: Index) -> Int { distance(from: startIndex, to: index) }
}
extension String.Index {
    func distance<S: StringProtocol>(in string: S) -> Int { string.distance(to: self) }
}

class Solution {   
    func strStr(_ haystack: String, _ needle: String) -> Int {
        let a = haystack.indexDistance(of: needle) ?? -1
        return a
    }
}
let s = Solution()
print(s.strStr("hello", "ll"))


var s = "123456";
print(s[s.index(s.startIndex, offsetBy: 4)] )//5



