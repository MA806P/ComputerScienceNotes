


链表
题目：21(合并有序链表)  24(两两交换链表节点)




动态规划：
从 n-1 得到 n 的解
题目：22(括号生成)  


树，遍历
搜索
回溯
题目：22(括号生成)  39(组合总和)



二分查找
题目：33(搜素旋转排序数组) 34(在排序数组中查找元素的第一个和最后一个位置)






分类：
1、数组中找和 = target。
	1-数组中找两个元素和
	15-数组中找三个元素和  16-三个元素和最接近 target
	18-数组中找四个元素和
	39 40 - 数组中找到和为target的所有组合





c ------


//链表
struct ListNode {
    int val;
    struct ListNode *next;
};

void dump(struct ListNode *head) {
    if (head == NULL) { printf("list null! \n"); }
    struct ListNode *node = head;
    while (node != NULL) {
        printf("%d -> ", node->val);
        node = node -> next;
    }
    printf("\n");
}
 struct ListNode l1 = {1, NULL};
 struct ListNode l2 = {2, &l1};
 struct ListNode l3 = {3, &l2};
 struct ListNode l4 = {4, &l3};
 struct ListNode l5 = {5, &l4};
 struct ListNode l6 = {6, &l5};
 dump(&l6);




//栈
typedef int  DATATYPE;
typedef struct _list_stack {
    DATATYPE data;
    int count;
    struct _list_stack *next;
} stack;
stack *stackCreate() {
    stack *s = (stack *)malloc(sizeof(stack));
    if (s == NULL) { return NULL; }
    s->next = NULL;
    s->count = 0;
    return s;
}
void stackDestroy(stack *s) {
    stack *tempS = NULL;
    while (s->next != NULL) {
        tempS = s->next;
        s->next = tempS->next;
        free(tempS);
    }
    free(s);
}
void stackPush(stack *s, DATATYPE data) {
    stack *node = (stack *)malloc(sizeof(stack));
    if (node == NULL) { return; }
    s->count += 1;
    node->data = data;
    node->count = s->count;
    node->next = s->next;
    s->next = node;
}
DATATYPE stackPop(stack *s) {
    if (s->next == NULL) { return 0; }
    stack *next = s->next;
    DATATYPE data = next->data;
    s->count -= 1;
    s->next = next->next;
    free(next);
    return data;
}
void stackDump(stack *s) {
    if (s->next == NULL) { printf("stack empty!\n"); return; }
    stack *next = s->next;
    while (next != NULL) {
        printf("-> %d ", next->data);
        next = next->next;
    }
    printf("\n");
}



//排序

//快速排序
//选择一元素(一般是最后一个)作为分界点，分界点前比它小，后面都是比它大的
//然后子分区继续这样分，直到最后只有一个元素
void swap_item(int *a, int *b) { int temp = *a; *a = *b; *b = temp; }
int partition(int *array, int p, int r) {
    int i = p;
    for (int j = p; j < r; j++) {
        if (array[j] < array[r]) {
            if (i != j) { swap_item(array + i, array + j); }
            i++;
        }
    }
    swap_item(array + i, array + r);
    return i;
}
void quick_sort(int *array, int p, int r) {
    if (p >= r) { return; }
    int q = partition(array, p, r);
    quick_sort(array, p, q - 1);
    quick_sort(array, q + 1, r);
}







swift ------





