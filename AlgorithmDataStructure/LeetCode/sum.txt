




动态规划：
从 n-1 得到 n 的解
题目：22(括号生成)  53(最大子序和) 32(最长有效括号)



分治法解决问题的模板：
1、定义基本情况。
2、将问题分解为子问题并递归地解决它们。
3、合并子问题的解以获得原始问题的解。


贪心算法：
捡到西瓜，丢了芝麻。就是贪心，贪最大的，小的放弃扔了。
题目：53(最大子序和)




树，遍历
搜索
回溯算法：是一种通过探索所有可能的候选解来找出所有的解的算法。递归实现。
回溯，类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。
题目：22(括号生成)  39 40(组合总和) 46(全排列)


广度优先搜索
就是从起点出发，每次都尝试访问同一层的节点，如果同一层都访问完了，再访问下一层，最后广度优先搜索找到的路径就是从起点开始的最短合法路径。
题目：994(腐烂的橘子)  



二分
二分查找
题目：33(搜素旋转排序数组) 34(在排序数组中查找元素的第一个和最后一个位置)
二分递归、合并
题目：23(合并K个排序链表)





经典题目：
53(最大子序和)


分类：
1、数组中找和 = target。
	1-数组中找两个元素和
	15-数组中找三个元素和  16-三个元素和最接近 target
	18-数组中找四个元素和
	39 40 - 数组中找到和为target的所有组合


2、合并多个有序数组、链表
	21-合并两个有序链表
	23-合并K个有序链表
	A1001-合并有序的数组


3、链表反转
	206-反转链表
	24-两两交换链表中的节点 两个一组翻转
	25-K 个一组翻转链表


4、所有组合
	22(括号生成)
	46(全排列)




//--------------- c --------------- 

//--- 链表 ---
struct ListNode {
    int val;
    struct ListNode *next;
};

void dump(struct ListNode *head) {
    if (head == NULL) { printf("list null! \n"); }
    struct ListNode *node = head;
    while (node != NULL) {
        printf("%d -> ", node->val);
        node = node -> next;
    }
    printf("\n");
}
 struct ListNode l1 = {1, NULL};
 struct ListNode l2 = {2, &l1};
 struct ListNode l3 = {3, &l2};
 struct ListNode l4 = {4, &l3};
 dump(&l3);




//--- 栈 ---
typedef int  DATATYPE;
typedef struct _list_stack {
    DATATYPE data;
    int count;
    struct _list_stack *next;
} stack;
stack *stackCreate() {
    stack *s = (stack *)malloc(sizeof(stack));
    if (s == NULL) { return NULL; }
    s->next = NULL;
    s->count = 0;
    return s;
}
void stackDestroy(stack *s) {
    stack *tempS = NULL;
    while (s->next != NULL) {
        tempS = s->next;
        s->next = tempS->next;
        free(tempS);
    }
    free(s);
}
void stackPush(stack *s, DATATYPE data) {
    stack *node = (stack *)malloc(sizeof(stack));
    if (node == NULL) { return; }
    s->count += 1;
    node->data = data;
    node->count = s->count;
    node->next = s->next;
    s->next = node;
}
DATATYPE stackPop(stack *s) {
    if (s->next == NULL) { return 0; }
    stack *next = s->next;
    DATATYPE data = next->data;
    s->count -= 1;
    s->next = next->next;
    free(next);
    return data;
}
void stackDump(stack *s) {
    if (s->next == NULL) { printf("stack empty!\n"); return; }
    stack *next = s->next;
    while (next != NULL) {
        printf("-> %d ", next->data);
        next = next->next;
    }
    printf("\n");
}


/*
//--- 栈 ---
struct stack_node {
    int data;
    struct stack_node *next;
};
typedef struct {
    struct stack_node *next;
} MyStack;
MyStack* myStackCreate() {
    MyStack *stack = (MyStack *)malloc(sizeof(MyStack));
    if (stack == NULL) { return NULL; }
    stack->next = NULL;
    return stack;
}
void myStackPush(MyStack* obj, int x) {
    if (obj == NULL) { return; }
    struct stack_node *node = (struct stack_node*)malloc(sizeof(struct stack_node));
    if (node == NULL) { return; }
    node->data = x;
    node->next = obj->next;
    obj->next = node;
}
int myStackPop(MyStack* obj) {
    if (obj == NULL || obj->next == NULL) { return -1; }
    struct stack_node *node = obj->next;
    obj->next = node->next;
    int data = node->data;
    free(node);
    return data;
}
int myStackTop(MyStack* obj) {
    if (obj == NULL || obj->next == NULL) {return -1; }
    return obj->next->data;
}
bool myStackEmpty(MyStack* obj) {
    if (obj == NULL) { return true; }
    return obj->next == NULL;
}

void myStackFree(MyStack* obj) {
    if (obj == NULL) { return; }
    while (obj->next != NULL) { myStackPop(obj); }
    free(obj);
}
*/






//--------------- 排序 --------------- 

//快速排序
//选择一元素(一般是最后一个)作为分界点，分界点前比它小，后面都是比它大的
//然后子分区继续这样分，直到最后只有一个元素
void swap_item(int *a, int *b) { int temp = *a; *a = *b; *b = temp; }
int partition(int *array, int p, int r) {
    int i = p;
    for (int j = p; j < r; j++) {
        if (array[j] < array[r]) {
            if (i != j) { swap_item(array + i, array + j); }
            i++;
        }
    }
    swap_item(array + i, array + r);
    return i;
}
void quick_sort(int *array, int p, int r) {
    if (p >= r) { return; }
    int q = partition(array, p, r);
    quick_sort(array, p, q - 1);
    quick_sort(array, q + 1, r);
}








//--------------- swift --------------- 

extension StringProtocol {
    func indexDistance<S: StringProtocol>(of string: S) -> Int? { range(of: string)?.lowerBound.distance(in: self) }
}
extension Collection {
    func distance(to index: Index) -> Int { distance(from: startIndex, to: index) }
}
extension String.Index {
    func distance<S: StringProtocol>(in string: S) -> Int { string.distance(to: self) }
}

class Solution {   
    func strStr(_ haystack: String, _ needle: String) -> Int {
        let a = haystack.indexDistance(of: needle) ?? -1
        return a
    }
}
let s = Solution()
print(s.strStr("hello", "ll"))


var s = "123456";
print(s[s.index(s.startIndex, offsetBy: 4)] )//5



