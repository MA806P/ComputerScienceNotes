### 二分查找

二分查找针对的是一个有序的数据集合,查找思想有点类似分治思想。每次都通过跟区间的中间元素对比,将待查找的区间缩小为之前的一半,直到找到要查找的元素,或者区间被缩小为0。  

二分法查找：时间复杂度 O(logn)。  
容易出错的地方：循环退出条件、mid 的取值，low 和 high 的更新。

二分法查找局限性：  
1、依赖顺序表结构，数组   
2、针对有序数据。只能用在插入、删除操作不频繁，一次排序多次查找的场景中  
3、数据量太小不适合二分查找。顺序遍历就可以了。  
    如果数据之间的比较操作非常耗时，不管数据量大小，都推荐使用二分查找。  
4、数据量太大也不适合二分查找  
    比如，我们有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。 
    注意这里的“连续”二字，也就是说，即便有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB 大小的数组。而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。  
    
    
    


十个二分九个错，虽然原理简单，但是想要写出没有 bug 的二分查找并不容易。  
常见二分查找变形问题：  
* 查找第一个值等于给定值的元素  
* 查找最后一个值等于给定值的元素  
* 查找第一个大于等于给定值的元素
* 查找最后一个小于等于给定值的元素  


<br>


### 跳表  
二分查找底层依赖的是数组随机访问的特性，所以只能用数组来实现。  
如果数据存储在链表中，只需对链表稍加改造，就可以支持类似 二分 的查找算法。把改造之后的数据结构叫做跳表。  
跳表，各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删除、查找操作，甚至可以替代红黑树。  
跳表 = 链表 + 索引  
跳表中查询一个数据的时间复杂度：O(m*logn)，每一级索引最多只需遍历3个结点 m = 3 ，时间复杂度和二分查找是一样的，其实是基于单链表实现了二分查找。  
空间复杂度：O(n)，几级索引点的总和，n/2+n/4+n/8...+4+2 = n-2。 在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。  


跳表，高效的动态插入和删除  
1、插入：可能出现在某2个索引之间插入的数据非常多，极端情况会退化成单链表，需要维护索引与原始链表大小之间的平衡。跳表索引动态更新。跳表是通过随机函数来维护平衡性，通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。  
2、删除：除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。  

















