### 排序算法


| 排序算法 | 时间复杂度 | 是否基于比较 |
| --- | --- | --- |
| 冒泡、插入、选择 | O(n^2) | 是  |
| 快排、归并 | O(nlogn) | 是 |
| 桶排序、计数排序、基数排序 | O(n) | 否 |

<br>

一、排序算法的执行效率：  
1. 最好情况、最坏情况、平均情况，时间复杂度  
2. 时间复杂度的系数、常数、低阶  
3. 比较次数和交换（或移动）次数  


二、排序算法的内存消耗  
算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。


三、排序算法的稳定性  
如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。  


-------

`
有序度是数组中具有有序关系的元素对的个数  
对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是n*(n-1)/2，也就是 15。我们把这种完全有序的数组的有序度叫作满有序度。  

逆序度 = 满有序度 - 有序度。  
我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。 
`   


一、冒泡排序算法：  
1、空间复杂度 O(1)，是一个原地排序算法  
2、为保证冒泡排序算法的稳定性，当有相邻两个元素大小相等的时候，不做交换 前后顺序不变，所以是冒泡排序是稳定的排序算法  
3、时间复杂度，最好 O(n)，最坏 O(n^2)  

冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是n*(n-1)/2–初始有序度。  
4 5 6 3 2 1 ，此例中就是 15–3=12，要进行 12 次交换操作。  

最坏情况下，初始状态的有序度是 0，所以要进行 n\*(n-1)/2 次交换。最好情况下，初始状态的有序度是 n\*(n-1)/2，就不需要进行交换。我们可以取个中间值 n\*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。 换句话说，平均情况下，需要 n\*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n^2)，所以平均情况下的时间复杂度就是 O(n^2)。  


二、插入排序  
插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。  
对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。  
1、不需要额外的存储空间，空间复杂度 O(1)，是一个原地排序算法  
2、可选择后面出现的元素，插入到前面出现元素的后面，可保持原有顺序不变，是稳定的排序算法。  
3、时间复杂度，  
    最好 O(n) -- 从尾到头遍历已经有序的数据  
    最坏 O(n^2)  
    平均时间复杂度 O(n^2) -- 在数组中插入一个数据的平均时间复杂度 O(n)，插入排序每次插入操作相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度 O(n^2)  
    
    
三、选择排序  
选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。  
1、空间复杂度 O(1)，是一个原地排序算法  
2、不稳定的排序算法  
3、最坏、最好和平均时间复杂度都是 O(n^2)  


都是原地排序算法，插入排序要比冒泡排序更受欢迎。  
从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。  
虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n2)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间  


<br>

|  | 原地排序 | 稳定 | 最好 | 最坏 | 平均 |
| --- | --- | --- | --- | --- | --- |
| 冒泡 | 是 | 是 | O(n) | O(n^2) | O(n^2) |
| 插入 | 是 | 是 | O(n) | O(n^2) | O(n^2) |
| 选择 | 是 | 否 | O(n^2)  | O(n^2) | O(n^2) |


希尔排序
https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F

<br>

https://visualgo.net/en  
https://mp.weixin.qq.com/s/HQg3BzzQfJXcWyltsgOfCQ


<br>

-------

<br>


一、归并排序  
要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。分而治之  
分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。  

1、稳定的排序算法  
2、时间复杂度  O(nlogn)  
3、空间复杂度 O(n)，归并排序不是原地排序算法，在合并两个有序数组时，需要借助额外的存储空间。在任意时刻， CPU 只会有一个函数在执行，只会有一个临时的内存空间在使用，所以空间复杂度是 O(n)。  


二、快速排序  
如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。  

1、不稳定的排序算法。  
2、时间复杂度  O(nlogn)，最坏情况不是一分为二 需要n次分区操作才能完成 O(n^2)。  
    一个是分区机器均衡，一个是分区及其不均衡。在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n^2)。


归并排序的处理过程是由下到上，先处理子问题，然后再合并。  
快排正好相反，处理过程由上到下，先分区，然后再处理子问题。  
快排通过设计巧妙的原地分区函数，可实现原地排序，解决了归并排序占用太多内存的问题。  



<br>

-------

<br>

一、桶排序  
将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。  

如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。  

1、通排序对要排序数据的要求非常苛刻。  
    要排序的数据需要很容易就能划分成 m 个桶，桶和桶之间有天然的大小顺序，这样每个桶数据排序完之后，桶之间的数据就不需要再进行排序。  

2、数据在各个桶之间的分布是比较均匀的。  
3、桶排序比较适合用在外部排序中。数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。   



二、计数排序  
计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。  

计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。  



三、基数排序  
基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。  

有时候要排序的数据并不都是等长的，例如英文单词，我们可以把所有的单词补齐到相同长度，位数不够的可以在后面补“0”  


-------


![](https://github.com/MA806P/ComputerScienceNotes/blob/master/AlgorithmDataStructure/Notes/Images/2-Sort.jpg)


线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。  

如果对小规模数据进行排序，可以选择时间复杂度是 O(n2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。  

归并排序：  
    不是原地排序算法，空间复杂度O(n)，如果要排序 100MB 的数据，除了数据本身占用的内存之外，排序算法还要额外再占用 100MB 的内存空间，空间耗费就翻倍了。  

快速排序：  
    优化分区点，理想分区点--被分区点分开的两个分区中，数据的数量差不多。
    三数取中法。  
    随机法。  
    递归要警惕堆栈溢出。1、限制递归深度。2、通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。  
    

