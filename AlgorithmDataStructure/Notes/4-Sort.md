### 排序算法


| 排序算法 | 时间复杂度 | 是否基于比较 |
| --- | --- | --- |
| 冒泡、插入、选择 | O(n^2) | 是  |
| 快排、归并 | O(nlogn) | 是 |
| 桶排序、计数排序、基数排序 | O(n) | 否 |

<br>

一、排序算法的执行效率：  
1. 最好情况、最坏情况、平均情况，时间复杂度  
2. 时间复杂度的系数、常数、低阶  
3. 比较次数和交换（或移动）次数  


二、排序算法的内存消耗  
算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。


三、排序算法的稳定性  
如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。  


-------

`
有序度是数组中具有有序关系的元素对的个数  
对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是n*(n-1)/2，也就是 15。我们把这种完全有序的数组的有序度叫作满有序度。  

逆序度 = 满有序度 - 有序度。  
我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。 
`   


一、冒泡排序算法：  
1、空间复杂度 O(1)，是一个原地排序算法  
2、为保证冒泡排序算法的稳定性，当有相邻两个元素大小相等的时候，不做交换 前后顺序不变，所以是冒泡排序是稳定的排序算法  
3、时间复杂度，最好 O(n)，最坏 O(n^2)  

冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是n*(n-1)/2–初始有序度。  
4 5 6 3 2 1 ，此例中就是 15–3=12，要进行 12 次交换操作。  

最坏情况下，初始状态的有序度是 0，所以要进行 n\*(n-1)/2 次交换。最好情况下，初始状态的有序度是 n\*(n-1)/2，就不需要进行交换。我们可以取个中间值 n\*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。 换句话说，平均情况下，需要 n\*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n^2)，所以平均情况下的时间复杂度就是 O(n^2)。  


二、插入排序  
插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。  
对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。  
1、不需要额外的存储空间，空间复杂度 O(1)，是一个原地排序算法  
2、可选择后面出现的元素，插入到前面出现元素的后面，可保持原有顺序不变，是稳定的排序算法。  
3、时间复杂度，  
    最好 O(n) -- 从尾到头遍历已经有序的数据  
    最坏 O(n^2)  
    平均时间复杂度 O(n^2) -- 在数组中插入一个数据的平均时间复杂度 O(n)，插入排序每次插入操作相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度 O(n^2)  
    
    
三、选择排序  
选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。  
1、空间复杂度 O(1)，是一个原地排序算法  
2、不稳定的排序算法  
3、最坏、最好和平均时间复杂度都是 O(n^2)  


都是原地排序算法，插入排序要比冒泡排序更受欢迎。  
从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。  
虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n2)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间  


<br>

|  | 原地排序 | 稳定 | 最好 | 最坏 | 平均 |
| --- | --- | --- | --- | --- | --- |
| 冒泡 | 是 | 是 | O(n) | O(n^2) | O(n^2) |
| 插入 | 是 | 是 | O(n) | O(n^2) | O(n^2) |
| 选择 | 是 | 否 | O(n^2)  | O(n^2) | O(n^2) |


希尔排序
https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F

<br>

https://visualgo.net/en  
https://mp.weixin.qq.com/s/HQg3BzzQfJXcWyltsgOfCQ


<br>
<br>
<br>


一、归并排序  
要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。分而治之  
分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。  

1、稳定的排序算法  
2、时间复杂度  O(nlogn)  
3、空间复杂度 O(n)，归并排序不是原地排序算法，在合并两个有序数组时，需要借助额外的存储空间。在任意时刻， CPU 只会有一个函数在执行，只会有一个临时的内存空间在使用，所以空间复杂度是 O(n)。  


二、快速排序  
如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。  

1、不稳定的排序算法。  
2、时间复杂度  O(nlogn)，最坏情况不是一分为二 需要n次分区操作才能完成 O(n^2)。  
    一个是分区机器均衡，一个是分区及其不均衡。在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n^2)。


归并排序的处理过程是由下到上，先处理子问题，然后再合并。  
快排正好相反，处理过程由上到下，先分区，然后再处理子问题。  
快排通过设计巧妙的原地分区函数，可实现原地排序，解决了归并排序占用太多内存的问题。  







  





    
    
