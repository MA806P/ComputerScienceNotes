


# 静态、动态链接

OC  Swift，都是编译型语言。对于编译型语言，源代码会首先经由编译器编译为目标文件，链接器再将多个目标文件链接为可执行文件。
针对链接阶段，主要分为静态链接与动态链接。

静态，即 Static。静态即一旦确定，就不再容易改变。
静态链接，即在链接阶段，直接将多个目标文件链接为一个文件。而静态库就可以理解为共同编译为一个目标文件的源代码集合。
静态库即静态链接库（Windows 下的 .lib，Linux 和 Mac 下的 .a）。之所以叫做静态，是因为静态库在编译的时候会被直接拷贝一份，复制到目标程序里，这段代码在目标程序里就不会再改变了。
静态库的好处很明显，运行时不再额外需要时间动态链接。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大，可能会链接了没有使用到的函数。而且当某一个目标文件的源代码改动时，那么所有依赖该目标文件的静态库都需要重新编译；

动态，即 Dynamic。动态即推迟到运行时动态地决议。
动态链接，即在运行时才将各个部分组合形成完整的程序。而动态库就可以理解为支持动态链接方式的源代码集合。
动态库即动态链接库（Windows 下的 .dll，Linux 下的 .so，Mac 下的 .dylib）。与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来。
动态库的优点是，不需要拷贝到目标程序中，不会影响目标程序的体积，而且同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。同时，编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。动态库带来的问题主要是，动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行（Linux 下喜闻乐见的 lib not found 错误）。

动态链接则解决了静态链接的空间浪费与重复编译问题，比如在 iOS 中，系统库采用了 dyld_shared_cache 动态链接，这样其它程序就无需再将系统库重复链接，当 iOS 系统更新时也无需将所有 app 重新编译。而在移动端开发中，app 的启动时间与包体积大小将是一个权衡问题，值得我们侧重与考量。  






Library  
库是您保存预先编写的代码的地方，您可以调用这些代码来帮助您更快、更轻松地完成工作。 该库基本上是一组元素，例如函数、类、常量、变量等，您可以在项目中使用它们来制作应用程序。  

Framework  
框架是一个大型Library或一组Library，提供许多服务（而不是像大多数Library那样只是一个集中的能力）。框架包括许多工具，例如 API 和库，可促进应用程序的开发。框架提供了一个完整的基础，您可以在此基础上构建自己的代码，而不是构建使用库代码来完成部分工作的应用程序。  

SDK  
Software Development Kit 这是针对特定平台的完整软件开发工具套件。 这个“套件”可以包括各种东西，例如：库、API、IDE、文档等。例如，Android SDK，它提供了 Android 开发所需的一切。


另外，虽然广义上的库（Library）与框架（Framework）含义是类似的，但在 iOS 开发中，官方将这两个概念进行了区分。
Xcode 新建 iOS 项目时，有 Static Library 和 Framework 选项。

Static Library 即静态库。iOS 上狭义的静态库，即只包含编译后代码的 .a 文件。
在 Xcode 9 之后，Swift 也支持了静态库。与 Obj-C 不同，Swift 没有头文件的概念，因此我们需要将暴露给外界的类和函数等使用 public 修饰。编译后的 Swift 静态库也是 .a 文件，但不同的是多了 .swiftmodule 以及 .swiftdoc

以上来自 https://kingcos.me/posts/2019/libraries_in_ios/  
https://segmentfault.com/a/1190000004920754


一个完整的模块不仅有代码，还可能包含.h 头文修的、.nib 视图文件、图片资源文件、说明文档。Framework 作为 Cocoa/Cocoa Touch 中使用的一种资源打包方式，可以上述文件等集中打包在一起，方便开发者使用（就像Bundle）。

在 macOS、iOS 中静态库格式 .a，动态库格式 .dylib。 .a /.dylib 等只能打包库的二进制代码
Mac OS/iOS 平台的 Framework，实际上是一种打包方式，将库的二进制文件，头文件和有关的资源文件打包到一起，方便管理和分发。
动态库.a/静态库.dylib + .h + 资源文件 = Framework. 

关于动态的 Framework
真正动态的 Framework ，只有苹果自家的 UIKit.Framework，Foundation.Framework 等。
由于 iOS 的沙盒机制，自己创建的 Framework 和系统 Framework 不同，App 中使用的 Framework 运行在沙盒里，而不是系统中。每个 App 都只能用自己对应签名的动态库，做不到多个 App 使用一个动态库。
如果不同的 App 使用了同样的 Framework，还是会有多份的 Framework 被分别签名，打包和加载。
所以，iOS 上的动态库只能是私有的，我们无法将动态库放置在除了自身沙盒以外的地方。

CocoaPods 类似于 Android 的 gradle。不过gradle 还能负责构建, CocoaPods 只管理依赖。
CocoaPods 目前分别支持了 Framework 动态库和 .a 静态库 2种方式。
默认使用的是 .a 静态库的方式，主工程依赖 libPods.a，通过脚本，把资源等文件复制到目标目录。
在 Podfile 使用了 use_frameworks! 进行声明,则使用 Framework 动态库的形式.主工程对 Pods 的依赖为 Pods.framework。
由于 Xcode9 之前 Swift 项目不支持静态库，如果为 Swift 项目，就必须采用 user_frameworks! 声明。



可以在一个项目中使用一部分动态库, 再使用一部分静态库, 如果涉及到第三方库与库之间的依赖关系时, 那么遵守如下原则:
* 静态库可以依赖静态库
* 动态库可以依赖动态库
* 动态库不能依赖静态库! 
动态库不能依赖静态库是因为静态库不需要在运行时再次加载, 如果多个动态库依赖同一个静态库, 会出现多个静态库的拷贝, 而这些拷贝本身只是对于内存空间的消耗.





