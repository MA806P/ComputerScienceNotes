·# Computer Network Notes
Computer Network

### 一、网络协议
协议
通过协议，计算机才知道我们想让它做什么。
（程序编译）原文件 ---> 词法分析  ---> 语法分析 ---> 语义分析 ---> 代码生成 ---> 目标文件
协议三要素：语法、语义、顺序
通过网络协议，才能使一大片机器相互协作、共同完成一件事。

在浏览器输入地址URL，DNS查找具体地址，IP地址互联网世界的门牌号。知道了地址浏览器开始打包请求，通常会使用HTTP协议，DNS HTTP HTTPS 所在的层成为应用层，应用层封装后，将应用层的包交给下一层去完成，通过 socket 编程来实现。
下一层传输层 UDP无连接的协议、 TCP面向连接的协议，TCP会保证这个包到达目的地，如果不到重新发送直到到达，TCP协议有两个端口浏览器端口、服务器监听的端口，操作系统通过端口来判断，得到的包应交给哪个进程，传输层封装完毕后，浏览器会将包交给操作系统的网络层。
网络层的协议是 IP 协议，知道了IP地址，操作系统根据IP地址，判断是去本地 还是去外地，去外地，将包发送给网关，通过ARP协议获取网关MAC地址，然后操作系统将IP包交给下一层。
MAC层，可以到达网关，网关收到判断下一步怎么走，网关往往是个路由器，路线叫做路由表。网关拿到包后取出IP头判断下步怎么走，用到路由协议，OSPF BGP。
一步步到目标服务器发现MAC地址对上，取下MAC头，发送给操作系统的网络层，发现IP也对上就取下IP头，发现上一层封装的是TCP协议，然后交给传输层，即TCP层，这层对于收到的每一个包，都会有个回复的说明，沿着刚才的方向回去，说明收到这个包。
可能会走丢，因而要报平安，如果一段时间没到，发送端的TCP层会重新发送这个包，直到收到回复。
当网络包平安到达TCP层之后，TCP头有目标端口，这个可以找到具体的应用进程。

应用层： DHCP  HTTP  HTTPS  RTMP  P2P DNS  GTP  RPC
传输层:   UDP TCP
网络层：ICMP IP OSPF BGP IPSec GRE
链路层：ARP VLAN STP
物理层：网络路线

当网络包到达一个城关的时候，可以通过路由表得到下一个城关的IP 地址，直接通过 IP 地址找就可以了，为什么还要通过本地MAC地址呢？


### 二、网络分层

问题一，TCP在进行三次握手时，IP层和MAC层对应都有什么操作呢，协议之间的关系
问题二，IP协议包含目标地址和源地址，路由协议从地址A到地址D，中间经过中转站A->B->C->D。
A知道自己的下一个中转站是B，那从A发出来的包，应该把B的IP地址放在哪里？如果放在IP协议中的目标地址，包到了中转站，怎么知道最终的目的地址是D呢？
问题三，二层设备处理的包里，有没有HTTP层的内容呢？
问题四，从电脑通过SSH登陆到公有云主机里面，都需要经历哪些过程？打开一个电商网站都需要经历哪些过程？

尽管每一层都很熟悉，但是知识点串起来很难。


网络为什么要分层：
想象网络包就是一段Buffer或者一块内存，是有格式的。同时想象自己是一个处理网络包的程序，程序可以运行在电脑上、服务器上、交换机上、路由器上，从某一个网口拿进一个网络包来，用自己的程序处理一下，再从另一个网口发送出去。
当网络包的格式很复杂，这个程序也很复杂。复杂的程序都要分层，这是程序设计的要求。
例如复杂的电商会分为数据库层、缓存层、Compose层、Controller层和接入层，每一层专注做本层的事情。

当网络包经过一个网口的时候，先看看要不要请进来处理一把，有的网口设置了混杂模式，凡是经过的，全部拿进来。
拿进来以后，交个一段程序来处理process_layer2(buffer)，摘掉MAC层头部，看一看根据头部内容做操作，发现MAC地址和你的相符，说明是发给你的，于是需要调用下一段程序
process_layer3(buffer)，这是buffer里就没有二层的头部了，在上一层被拿掉了，或者将开始的偏移量移动了一下 。在layer3这个函数里，摘掉三层的头，看看是发送给自己的还是希望自己转发出去，根据IP地址，是自己的IP那就是发送给自己的，根据IP头里的标志，拿掉三层的头部，进行下一层的处理，
假设是地址是TCP的，则会调用process_tcp(buffer)，这时 buffer 里没有三层的头，查看四层的头部，判断是应答还是发起(接下来发送一个回复包)，又或者是一个正常的数据包(交给上一层处理)，然后分别根据不同的逻辑进行处理。
下一层应该交给应用去处理，在四层的头部里有端口号，不同的应用监听不同的端口号，如发现浏览器应用在监听这个端口，就发给浏览器就行，剩下的浏览器处理，
浏览器解析HTML显示页面。当点击浏览器的内容被捕获，然后又要发送一个HTTP请求，于是使用端口号，将请求发送给你，你调用 send_tcp(buffer) buffer里就是HTTP的请求内容，加上TCP的头，记录源端口号一般为80端口，然后调用send_layer3(buffer) 在这里加上IP的头，记录下源IP地址和目标IP的地址。
然后调用send_layer2(buffer) 加上MAC的头部，记录下源MAC地址，本机MAC地址和目标MAC地址，知道就加上，不知道根据协议处理，找到MAC地址。
然后只要buffer里的内容完整，就可以从网口出去。


TCP在三次握手时，每发送一个消息都会带着IP层和MAC层，所以的机制都要运行一遍，IP层和MAC层都在忙活。
只要是在网络上跑的包，都是完整的，可以有下层没上层，绝不可能有上层没下层。
你只知道IP地址，直接给他发消息，没有MAC地址消息是发不出去的。
所以一个HTTP协议的包跑在网络上，他一定是完整的。
所谓的二层、三层设备，都是这些设备上跑的程序不同而已。




