·# Computer Network Notes
Computer Network

### 一、网络协议
协议
通过协议，计算机才知道我们想让它做什么。
（程序编译）原文件 ---> 词法分析  ---> 语法分析 ---> 语义分析 ---> 代码生成 ---> 目标文件
协议三要素：语法、语义、顺序
通过网络协议，才能使一大片机器相互协作、共同完成一件事。

在浏览器输入地址URL，DNS查找具体地址，IP地址互联网世界的门牌号。知道了地址浏览器开始打包请求，通常会使用HTTP协议，DNS HTTP HTTPS 所在的层成为应用层，应用层封装后，将应用层的包交给下一层去完成，通过 socket 编程来实现。
下一层传输层 UDP无连接的协议、 TCP面向连接的协议，TCP会保证这个包到达目的地，如果不到重新发送直到到达，TCP协议有两个端口浏览器端口、服务器监听的端口，操作系统通过端口来判断，得到的包应交给哪个进程，传输层封装完毕后，浏览器会将包交给操作系统的网络层。
网络层的协议是 IP 协议，知道了IP地址，操作系统根据IP地址，判断是去本地 还是去外地，去外地，将包发送给网关，通过ARP协议获取网关MAC地址，然后操作系统将IP包交给下一层。
MAC层，可以到达网关，网关收到判断下一步怎么走，网关往往是个路由器，路线叫做路由表。网关拿到包后取出IP头判断下步怎么走，用到路由协议，OSPF BGP。
一步步到目标服务器发现MAC地址对上，取下MAC头，发送给操作系统的网络层，发现IP也对上就取下IP头，发现上一层封装的是TCP协议，然后交给传输层，即TCP层，这层对于收到的每一个包，都会有个回复的说明，沿着刚才的方向回去，说明收到这个包。
可能会走丢，因而要报平安，如果一段时间没到，发送端的TCP层会重新发送这个包，直到收到回复。
当网络包平安到达TCP层之后，TCP头有目标端口，这个可以找到具体的应用进程。

应用层： DHCP  HTTP  HTTPS  RTMP  P2P DNS  GTP  RPC
传输层:   UDP TCP
网络层：ICMP IP OSPF BGP IPSec GRE
链路层：ARP VLAN STP
物理层：网络路线

当网络包到达一个城关的时候，可以通过路由表得到下一个城关的IP 地址，直接通过 IP 地址找就可以了，为什么还要通过本地MAC地址呢？


### 二、网络分层

问题一，TCP在进行三次握手时，IP层和MAC层对应都有什么操作呢，协议之间的关系
问题二，IP协议包含目标地址和源地址，路由协议从地址A到地址D，中间经过中转站A->B->C->D。
A知道自己的下一个中转站是B，那从A发出来的包，应该把B的IP地址放在哪里？如果放在IP协议中的目标地址，包到了中转站，怎么知道最终的目的地址是D呢？
问题三，二层设备处理的包里，有没有HTTP层的内容呢？
问题四，从电脑通过SSH登陆到公有云主机里面，都需要经历哪些过程？打开一个电商网站都需要经历哪些过程？

尽管每一层都很熟悉，但是知识点串起来很难。


网络为什么要分层：
想象网络包就是一段Buffer或者一块内存，是有格式的。同时想象自己是一个处理网络包的程序，程序可以运行在电脑上、服务器上、交换机上、路由器上，从某一个网口拿进一个网络包来，用自己的程序处理一下，再从另一个网口发送出去。
当网络包的格式很复杂，这个程序也很复杂。复杂的程序都要分层，这是程序设计的要求。
例如复杂的电商会分为数据库层、缓存层、Compose层、Controller层和接入层，每一层专注做本层的事情。

当网络包经过一个网口的时候，先看看要不要请进来处理一把，有的网口设置了混杂模式，凡是经过的，全部拿进来。
拿进来以后，交个一段程序来处理process_layer2(buffer)，摘掉MAC层头部，看一看根据头部内容做操作，发现MAC地址和你的相符，说明是发给你的，于是需要调用下一段程序
process_layer3(buffer)，这是buffer里就没有二层的头部了，在上一层被拿掉了，或者将开始的偏移量移动了一下 。在layer3这个函数里，摘掉三层的头，看看是发送给自己的还是希望自己转发出去，根据IP地址，是自己的IP那就是发送给自己的，根据IP头里的标志，拿掉三层的头部，进行下一层的处理，
假设是地址是TCP的，则会调用process_tcp(buffer)，这时 buffer 里没有三层的头，查看四层的头部，判断是应答还是发起(接下来发送一个回复包)，又或者是一个正常的数据包(交给上一层处理)，然后分别根据不同的逻辑进行处理。
下一层应该交给应用去处理，在四层的头部里有端口号，不同的应用监听不同的端口号，如发现浏览器应用在监听这个端口，就发给浏览器就行，剩下的浏览器处理，
浏览器解析HTML显示页面。当点击浏览器的内容被捕获，然后又要发送一个HTTP请求，于是使用端口号，将请求发送给你，你调用 send_tcp(buffer) buffer里就是HTTP的请求内容，加上TCP的头，记录源端口号一般为80端口，然后调用send_layer3(buffer) 在这里加上IP的头，记录下源IP地址和目标IP的地址。
然后调用send_layer2(buffer) 加上MAC的头部，记录下源MAC地址，本机MAC地址和目标MAC地址，知道就加上，不知道根据协议处理，找到MAC地址。
然后只要buffer里的内容完整，就可以从网口出去。


TCP在三次握手时，每发送一个消息都会带着IP层和MAC层，所以的机制都要运行一遍，IP层和MAC层都在忙活。
只要是在网络上跑的包，都是完整的，可以有下层没上层，绝不可能有上层没下层。
你只知道IP地址，直接给他发消息，没有MAC地址消息是发不出去的。
所以一个HTTP协议的包跑在网络上，他一定是完整的。
所谓的二层、三层设备，都是这些设备上跑的程序不同而已。




### ifconfig:最熟悉又陌生的命令行
怎样查看 IP 地址？
Windows 上 ipconfig
Linux 上是 ifconfig 和 ip addr

IP地址是网卡在网络世界的通讯地址。
32位 IP 地址，分为 5 类，A、B、C类主要分为两部分，前一部分网络号，后一部分主机号。
前几位ABCDE类地址
0
10
110
1110
11110
  	IP地址范围  		最大主机数  	私有IP地址范围
A 0.0.0.0--127.255.255.255    16777214	  10.0.0.0--10.255.255.255
B 128.0.0.0--191.255.255.255  65534  	  172.16.0.0--172.31.255.255
C 192.0.0.0--223.255.255.255  254	  192.168.0.0--192.168.255.255

无类型域间选路（CIDR）
将 32 位的 IP 地址一分为二，前面是网络号，后面是主机号。10.100.122.2/24，24的意思是，32位中，前24位是网络号，后8位是主机号。
伴随着CIDR存在的，一个是广播地址，10.100.122.255，如果发送这个地址，所有的10.100.122的网络里面的机器都可以收到。另一个是子网掩码，255.255.255.0。
将子网掩码和IP地址&运算，前三个数不变，第四个数为0，10.10.122.0这个就是网络号。
#### 将子网掩码和IP地址&计算就可得到网络号


公有IP地址和私有IP地址
私有IP地址，允许组织内部的IT人员自己管理、自己分配，而且可以重复。
公有IP地址，有组织统一分配，外部的人才能访问。
家里有WiFi，对应就会有有一个IP地址，一般家里上网设备不会超过256个，所以/24基本就够了，常见的还有/16的CIDR，8的倍数很明显容易理解。
如WiFi路由器地址为192.168.0.1，而192.168.0.255就是广播地址，一旦发送这个地址，整个192.1168.0网络里面的所有机器都能收到。


五类地址中的D类是组播地址，使用这个类地址，属于某个组的机器都能收到


root@test:~# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff
    inet 10.100.122.2/24 brd 10.100.122.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::f816:3eff:fec7:7975/64 scope link 
       valid_lft forever preferred_lft forever

对于网卡 eth0 来说是 global，说明这个网卡是可以对外的，可以接收来自各个地方的包。
lo 是host，说明这个网卡仅仅可以供本机互相通信。全称 loopback 回环接口，往往会被分配到 127.0.0.1 这个地址，用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。



MAC地址
link/ether 。。这个被称为MAC地址，一个网卡的物理地址，十六进制6个字节表示。
一个网络包要从一个地方传到另一个地方除了要有确定的地址，还需要有定位功能，而有门牌号属性的IP地址，才是有远程定位功能的。
MAC地址更像是身份证，是一个唯一的标识，是为了组网的时候，不同网卡放在一个网络里面的时候，可以不用担心冲突。从硬件角度，保证不同的网卡有不同标识。
MAC地址有一定的定位功能，但是通信范围比较小，局限在一个子网里。


网络设备的状态标识 net_device flags: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500
UP 标识网卡处于启动的状态； BROADCAST 表示这个网卡有广播地址，可以发送广播包；
MULTICAST 表示网卡可以发送多播包；LOWER_UP 表示L1是启动的，也即有网线插着。
mtu 1500：最大传输单元MUT为11500，这是以太网的默认值；
qdisc 全称是queueing discipline 排队规则，最简单的是pfifo不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列。pfifo_fast复杂一些队列包括撒个波段band，每个波段使用先进先出规则，波段的优先级也不相同。



小结：
IP是地址有定位功能；MAC是身份证无定位功能；
CIDR可以用来判断是不是本地人；
IP分公有和私有；


