
### 十四、HTTP 协议
http://www.163.com 是个 URL 叫做统一资源定位符。  

一、HTTP 请求的准备   
浏览器会将域名发送给 DNS 服务器，让它解析为 IP 地址。 然后建立 TCP 连接。目前使用的 HTTP 协议大部分是 1.1，在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样建立的 TCP 连接，就可以在多次请求中复用。   
<br>

二、HTTP 请求的构建   
建立了连接后，浏览器就要发送 HTTP 的请求。  
HTTP 的请求报文大概分为三大部分。请求行、首部、正文实体。  
<br>
请求行： 方法 sp URL sp 版本 cr If  
对于访问网页，常用类型是 GET 去服务器获取一些资源。  
POST 类型，需要主动告诉服务端一些信息。  
PUT 类型，向指定资源位置上传最新内容。HTTP 的服务器往往是不允许上传文件的，所以 PUT 和 POST 都变成了要传给服务器东西的方法。实际使用中两者还有些区别。POST 往往是用来创建一个资源，PUT 往往是用来修改一个资源的。  
DELETE 类型，用来删除资源的。例如要删除一个云主机，就会调用 DELETE 方法。
<br>
首部字段：key value，通过冒号分隔。  
Accept-Charset 表示客户端可以接受的字符集。防止传来的是另外的字符集，从而导致出现乱码。  
Content-Type 正文的格式。例如我们进行 POST 请求如果正文是 JSON，就应该将这个值设置为 JSON。  
缓存  
<br>
![](https://github.com/MA806P/ComputerScienceNotes/blob/master/ComputerNetwork/Images/6-Application-WebCache.jpg)
<br>
Nginx 这一层：对于静态资源，有 Varnish 缓存层，当缓存过期的时候，才会访问真正的 Tomcat 应用集群。  
Cache-control 是用来控制缓存的。当客户端发送的请求中包含 max-age 指令时，如果判定缓存层中，资源的缓存时间数值比指定的时间的数值小，那么客户端可以接受缓存的资源；当指定 max-age 值为0，那么缓存层通常需要将请求转发给应用集群。  
If-Modified-Since 这个也是一个关于缓存的，如果服务器的资源在某时间之后更新了，那么客户端就应该下载最新资源。如果没有更新，服务端会返回 304 not modified 的响应，客户端就不用下载了，也会节省宽带。  
<br>
HTTP 的请求报文确定好了之后，浏览器会把它交给下一层传输层，Socket 处理。 
<br>

三、HTTP 请求的发送  
HTTP 协议是基于 TCP 协议的，使用面向连接的方式发送请求，通过 stream 二进制流的方式传给对方。  
在发送给每个报文段的时候，都需要对方有一个回应 ACK ，来保证报文可靠到达对方。HTTP 不需要关系这些，TCP 来处理。TCP 层发送每一个报文的时候，都需要加上自己地址源地址和目标地址，将信息放到IP头里，交给IP层进行传输。  
IP 层查看目标地址和自己是否在同一个局域网。如果是，发送 ARP 协议来请求这个目标地址对应的 MAC 地址，然后将源和目标 MAC 放入 MAC 头，发送出去即可。如果不在同一个局域网，就需要发送到网关，ARP 协议获取网关的 MAC 地址，放入 MAC 中发送出去。  
网关收到包 MAC 符合，取出目标 IP 地址，根据路由协议找到下一跳路由器，获取下一跳路由器 MAC 地址，将包发送给下一跳路由器，最终到达目标局域网。最后一跳路由器发现目标地址就在自己的某一个出口的局域网上，在局域网上发送 ARP 获取目标地址的 MAC 地址，将包发出去。目标机器发现 MAC 地址符合，把包收起来，发现 IP 地址符合，根据 IP 头中协议项，知道自己上一层是 TCP 协议，解析 TCP 头，确认这个序列包是不是我要的，如果是放入缓存中然后返回一个 ACK ，如果不是就丢弃。

TCP 头里有端口号，HTTP 服务器正在监听这个端口号，目标机器知道 HTTP 服务器这个进程想要这个包，将包发送给它。HTTP 服务器的进程看到，请求是要访问一个网页，就把这个网页发给客户端。
<br>

四、HTTP 返回的构建  
返回的报文也是有一定格式的。  
状态码会反应 HTTP 请求的结果。 返回首部的 key value。  
Retry-After 表示，告诉客户端应该在多长时间后再次尝试。503 错误 服务器暂时不再和这个配合使用。  
Content-Type: HTML  JSON。  
构造好返回的 HTTP 报文，交给 Socket 发送，交给 TCP 层，TCP 层将返回的 HTML，也分成一个个小段，保证每段都可靠到达。当浏览器拿到 HTTP 的报文返回 200，一切正常，从正文中拿出 HTML，浏览器根据 HTML 格式展示网页。
<br>


五、HTTP 2.0  
1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 头，不考虑 pipeline 模式的话，每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题。  
2.0 为对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key value 在两端建立一个索引表，对相同的头只发送索引表中的索引。  
2.0 协议将一个 TCP 的连接中，切分成多个流，每个流都有自己的 ID，可相互发送 s->c c->s，其实只是一个虚拟的通道。流是有优先级的。  
2.0 还将所有的传输信息分割为更小的消息和帧，并采用二进制格式编码。常见的 Header 帧，用于传输 Header 内容，并且会开启一个新的流。Data 帧，用来传输正文实体。多个 Data 帧属于同一个流。  
这两种机制，2.0 的客户端可以将多个请求分到不同流中，将请求内容拆分成帧，进行二进制传输。这些帧可以乱序发送，然后根据每个帧首部流标识符组装，可以根据优先级优先处理哪个流的数据。   
举例，假设一个页面要发送三个独立的请求，获取 css js jpg，2.0 中实际是将三个请求变成三个流，将数据分成帧，乱序发送到一个 TCP 连接中，加快页面组件的传输速度。解决了 1.1 的队首拥塞问题，同时也不需要 1.X 的 pipeline 机制用多条 TCP 连接来实现并行请求与响应，减少 TCP 连接数对服务器性能的影响。  
<br>

六、QUIC 协议  
2.0 虽然大大增加了并发性，但还是有问题的。2.0是基于 TCP 协议的，TCP 协议在处理包时是有严格顺序的。当其中一个数据包遇到问题，TCP 连接需要等待这个包完成重传后才能继续进行。虽然 2.0 通过多个 stream 使得逻辑上一个 TCP 连接上的并行内容，进行多路数据的传输，这中间没有关联的数据。stream2的帧没收到，stream1的帧也会因此阻塞。  
<br>
QUIC:
机制一：定义连接机制  
一条 TCP 连接是由四元组标识的，源IP，源端口、目的IP、目的端口。一旦一个元素发生变化时，就需要断开重连。  
但是基于 UDP 就可以在 QUIC 自己的逻辑里面维护连接的机制，不再以四元组标识，而是以一个 64位随机数作为 ID来标识，只要 ID 不变，就不需要重新建立连接。  
机制二：自定义重传机制  
QUIC 序列号是递增的，任一个序列号的包只发一次，下次就要加一。QUIC 面向连接的，像 TCP 一样，是个数据流，发送的数据在这个数据流里有个偏移量 offset，可以查看数据发送到哪里，只要这个 offset 的包没来，就要重发，按照offset拼接，拼成一个流。  
机制三：无阻塞的多路复用  
同 2.0 一样，同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求。但是 QUIC 是基于 UDP 的，一个连接上的多个 steam 之间没有依赖。stream2丢了一个UDP包，需要重传，但是后面的stream3的包无需等待就可以发给用户。  
机制四：自定义流量控制  
TCP 的流量控制是通过滑动窗口协议。QUIC的流量控制也是通过 window_update 来告诉对端可以接受的字节数。但QUIC的窗口是适应自己的多路复用机制，不但在一个连接上控制窗口，还在一个连接中的每个 stream 控制窗口。

<br>
小结：  
1、HTTP 有 get post put delete 这几个方法。首部字段。  
2、HTTP 2.0 通过头压缩、分帧、二进制编码、多路复用等技术提升性能。  
3、QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进一步提升性能。
<br>


### 十五、HTTPS  
加密分为两种方式，对称加密、非对称加密  
一、对称加密  
对称加密算法中，加密和解密使用的密钥是相同的。  
对称加密算法要保证安全的话，密钥要做好保密，只能让使用的人知道，不能对外公开。  

<br>
二、非对称加密  
非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。  
一把公开的公钥，另一把私钥。公钥加密的信息只有私钥才能解密。私钥加密的信息，只有公钥才能解密。  
一对公钥私钥是不够的，客户端、服务端都要有自己的公钥私钥。  
客户端给购物网站发送的时候，用购物网站的公钥加密。网站给客户端发送消息的时候，使用客户端的公钥。这样就算中途被截获信息，没有私钥解不开。

<br>
三、数字证书  
不对称加密，如何将公钥给对方呢。一种是放在公网的地址上，让对方下载。另一种是在建立连接的时候，传给对方。  
怎么鉴别给你的公钥是对的，毕竟每个人都是可以创建自己的公钥和私钥。  

```
//创建私钥
openssl genrsa -out cliu8siteprivate.key 1024

//创建公钥
openssl rsa -in cliu8siteprivate.key -pubout -outcliu8sitepublic.pem
```  

证明身份，需要有权威部门颁发的证书。证书里有公钥、证书的所有者、发布机构、证书的有效期。  
生成证书需要发起证书请求，发给一个权威机构去认证，这个机构我们称为 CA ( Certificate Authority)  

```
证书请求：
openssl req -key cliu8siteprivate.key -new -out cliu8sitecertificate.req
```  

将这个请求发给权威机构，会给这个证书卡一个章，称为 签名算法。只有用只掌握在权威机构手里的东西签名了才行，这就是 CA 的私钥。  

签名算法：一般是对信息做一个 Hash 计算，得到一个 Hash 值，这个过程不可逆，无法通过 Hash 值得出原来的信息内容。在把这个信息发出去时，把这个 Hash 值加密后，作为一个签名和信息一起发出去。   
 
```
CA 给证书签名的命令：
openssl x509 -req -in cliu8sitecertificate.req -CA cacertificate.pem -CAkey caprivate.key -out cliu8sitecertificate.pem
//返回 Signature ok， cliu8sitecertificate.pem 就是签过名的证书
//CA 用自己的私钥给网站的公钥签名，就相当于给网站背书，形成网站的证书

查看证书内容：
openssl x509 -in cliu8sitecertificate.pem -noout -text 
// lssuer: 证书是谁颁发的
// Subject: 证书颁发给谁
// Validity: 证书期限
// Public-key: 公钥内容
// Signature Algorithm: 签名算法
```    

你不会从网站上得到一个公钥，而是会得到一个证书，证书有发布机构 CA ，得到这个 CA 的公钥，去解密网站证书的签名，解密成功，Hash 也对的上，就说明这个网站的公钥没问题。  
要想验证证书，需要 CA 的公钥，怎么确定 CA 的公钥是对的呢？  
CA 公钥也需要更牛的 CA 给它签名，然后形成 CA 的证书。要想知道某个 CA 的证书是否可靠，要看 CA 的上级证书的公钥，能不能解开这个 CA 签名。层层验证，知道全球皆知的几个著名大 CA ，root CA，这种层层授信背书的方式，保证非对称加密的正常运转。   

还有一种证书，Self-Signed Certificate，自己给自己签名，我就是我 爱信不信。哈哈哈


<br>
四、HTTPS 的工作模式  
HTTPS 协议的思路，将非对称和对称加密结合起来。公钥私钥主要用于对称加密的密钥，而真正的双方大数据量的通信都是通过对称加密进行的。  

当登陆购物网站时，由于是 HTTPS ，客户端会发送 Client Hello 消息到服务器，以明文传输 TLS 版本信息、加密套件候选列表、压缩算法候选列表等信息。另外，还会有个随机数，在协商对称密钥的时候使用。  

然后，网站返回 Server Hello 消息，告诉客户端，服务器选择使用的协议版本、加密套件、压缩算法等，还有随机数，用于后续的密钥协商。  

然后，网站会给你一个服务器端的证书。  

然后，客户端验证这个证书，从客户端自己信任的 CA 仓库中，拿 CA 证书里面的公钥去解密网站的证书。可能会不断往上追溯 CA 的 CA，直到一个授信的 CA。验证完毕后，网站可信，客户端计算产生随机数字 Pre-master, 发送 Client key Exchange，用证书中的公钥加密，在发送给服务器，服务器可以通过私钥解密出来。
然后，C S，都有三个随机数：自己的、对端、刚生成的 Pre-Master。通过这三个随机数，可以在 C S 产生相同的对称密钥。   

有了对称密钥，客户端，发送一个 Encrypted Handshake Message, 将已经商量好的参数等，采用协商密钥进行加密，发送给服务器用于数据与握手验证。服务器也发送 Encrypted Handshake Message 的消息试试。当双方握手结束后，就可以通过对称密钥进行加密传输了。  

这个过程除了加密解密之外，其他的过程和 HTTP 是一样的。
这只包含了 HTTPS 的单向认证 客户端验证服务端的证书，也可在更加严格安全要求的情况下，启用双向认证，双方互相验证证书。  

<br>
五、重放与篡改  
有了加密解密，截获的包也打不开了，但是它可以发送N次，通过 Timestamp 和 Nonce 随机数联合起来，然后做一个不可逆的签名来保证。  
Nonce 随机数保证唯一，或者 Timestamp 和 Nonce 合起来保证唯一，同样的请求只接受一次，多次则视为无效。  
如果有人想篡改 Timestamp 和 Nonce ，还有签名不可篡改性，如果改了用签名算法解出来，就对不上了，可丢弃。

<br>
小结：
* 对称加密效率高，解决不了密钥传输问题；非对称加密可解决，但是效率不高。
* 非对称加密需要通过证书和权威机构来验证公钥的合法性。
* HTTPS 综合了对称和非对称加密算法的 HTTP 协议。既保证传输安全，也保证传输效率。
<br>



### 十六、流媒体协议  

视频其实就是快速播放一连串连续的图片，每张图片称为帧，只要每秒的帧数据足够多，比如每秒30帧，以人的眼睛的敏感度，是看不出的，这就是常说的帧率 FPS。
如果都将所有帧图片都保存下来，视频太大，根本没办法存储和传输。  
人们想到了编码，用尽量少的 Bit 数保存视频，使播放的画面看起来任然没精美。编码是一个压缩的过程。  

视频和图片的特点：  
1、控件冗余：图像的相邻像素之间有较强的相关性，一张图相邻像素往往是渐变的，没必要每个像素都完整地保存，可以隔几个保存一个，中间的用算法计算出来。  
2、时间冗余：视频序列的相邻图像之间内容相似，可以根据已有的图片进行预测和推断。  
3、视觉冗余：人的视觉系统对某些细节不敏感，可以允许丢失一些数据。
4、编码冗余：不同像素值出现的概率不同，概率高的用的字节少，概率低的用的字节多   
<br>
![](https://github.com/MA806P/ComputerScienceNotes/blob/master/ComputerNetwork/Images/6-Application-ViewCode.jpg)
<br>

视频编码：  
* ITU（International Telecommunications Union) 的 VCEG (Vido Coding Experts Group)，国际电联下的 VCEG 。  H.265、H.264、...
* ISO (International Telecommunications Union) 的 VCEG ，ISO 旗下的 MPEG。 MPEG-1 MPEG-2 MPEG-4 MPEG-7

ITU-T 国际电信联盟电信标准化部门 Telecommunication Standardization Sector 与 MPEG 联合定制了 H.264/MPEG-4 AVC   
经过编码，一帧帧的图像，变成了二进制，二进制放在一个文件里，按照一定的格式保存起来，前几个字节是什么意义，后几个字节是什么意义，然后数据中保存的就是编码好的结果。RMVB MP4 MOV MKV   
<br>

直播  
编码后的二进制可以通过某种网络协议进行封装，在互联网上传输，进行网络直播。  
网络协议将编码好的视频流，从主播端推送到服务器，在服务器上运行的有同样协议的服务端来接收这些网络包，得到视频流 进行一定的处理 例如转码，称为接流。  
流处理完毕后，就可以等待客户端来请求这些视频流，客户端请求的过程称为拉流。  
如观众较多，从一个服务器上拉流，压力太大，需要一个视频的分发网络，将视频预先加载到就近的边缘节点，降低服务器压力。  
客户端将视频流拉下来后，就需进行解码，将二进制转成一帧帧图片，播放出来。
<br>

编码：  
视频序列分为三种帧  
* I帧，关键帧。里面是完整的图片，只需要本帧数据，就可以完成解码。 
* P帧，前向预测编码帧。P帧表示的是这一帧跟之前的一个关键帧或P帧的差别，解码时需要用之前缓存的画面，叠加上本帧定义的差别，生成最终画面。
* B帧，双向预测内插编码帧。B帧记录的是本帧与前后帧的差别。要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的数据的叠加，取得最终的画面。   

I帧最完整，B帧压缩率最高，而压缩后帧的序列，应该是 IBBP 的间隔出现的，这就是通过时序进行编码。   

在一帧中，分成多个片，每个片中分成多个宏块，每个宏块分成多个子块，这样将一张大的图分解成一个个小块，方便空间上的编码。  
压缩成二进制流，这个流的结构是一个个的网络提取层单元(NALU, Network Abstraction Layer Unit)，这种格式就是为了传输，网络上的传输默认的是一个个的包，因而这里分成了一个个的单元。<br>

![](https://github.com/MA806P/ComputerScienceNotes/blob/master/ComputerNetwork/Images/6-Application-NALN.jpg)

每个 NALU 首先是一个起始标识符，用于标识 NALU 之间的间隔。然后是 NALU 的头，主要配置了 NALU  的类型。Payload 里面是NALU承载的数据。  
NALU头里，主要内容是类型，NAL Type ：
* 0x07 表示 SPS ，是序列参数集，包括图像序列的所有信息，如图像尺寸、视频格式等。
* 0x08 表示 PPS，是图像参数集，包括一个图像的所有分片的所有相关信息，图片类型、序列号等。

每个 I 帧前面，都会传一遍这两个参数集合。如果 NALU Header 里面的表示类型是 SPS 或者 PPS，则 Payload 就是真正的参数集的内容。如果类型是帧，则 Payload 中才是真的视频数据。   

视频格式总结： 一个视频可以拆分成一系列的帧，每一帧拆分成一系列的片，每一片都放在一个 NALU 里，NALU 之间都是通过特殊的起始标识符分隔，在每一个 I 帧的第一片前面，要插入单独保存 SPS PPS 的NALU，最终形成一个长长的 NALU 序列。 
<br>

推流  
将编码后的二进制流打包成网路包进行发送，使用 RTMP 协议。
RTMP 是基于 TCP 的，因而需要双方建立 TCP 的连接，在 TCP 连接的基础上，还需要建立一个 RTMP 连接，也即在程序里需要调用 RTMP 类库的 Connect 函数，显式创建一个连接。
需要商量一些事情，保证以后的传输能正常运行。主要商量两件事，一是版本号，如 C S 版本号不一致，则不能工作。另一个时间戳，视频播放时间很重要，一开始双方就要知道对方的时间戳。

沟通需要发送六条消息：客户端发送 C0、C1、C2，服务器发送 S0、S1、S2。  
首先，客户端发送 C0 表示自己的版本号，不必等对方回复，然后发送C1表示自己的时间戳。  
服务器只有在收到 C0 的时候，才能返回 S0 表明自己的版本号，如果版本不匹配，可以断开连接。服务器发送完 S0 后，不用等什么，就直接发送自己的时间戳 S1。客户端收到 S1 发送一个知道了对方时间戳的 ACK C2。同理服务器收到 C1 的时候，发一个知道了对方时间戳的 ACK  S2。于是握手完成。
握手完成后，双方需要互相传递一些控制信息，如 Chunk 块的大小、窗口大小等。  
真正传输数据的时候，还是需要创建一个流 Stream，然后通过这个 Stream 来推流 publish。推流的过程，就是将 NALU 放在 Message 里面发送，这个也称为 RTMP Packet 包。   
Message Type(1字节)  Payload Lenght(3字节) Timestamp(4字节)  Steam ID(3字节)  Message Body  

发送的时候去掉 NALU 的起始标识符，将 SPS 和 PPS 参数集封装成一个 RTMP 包发送，然后发送一个个片的 NALU。  
RTMP 收发数据的时候并不是以 Message 为单位的，而是把 Message 拆分成 Chunk 发送，而且必须在 Chunk 发送完成之后，才能发送下一个 Chunk 。每个 Chunk 中都带有 Message ID，表示属于哪个 Message，接收端也会按照这个 ID 将 Chunk 组装成 Message。  
建立连接的时候，设置 Chunk 块大小就是指这个 Chunk。将大的消息变为小的块再发送，可以在低带宽的情况下，减少网络拥塞。  
大量观看直播的用户通过 RTMP 协议从流媒体服务器上拉取，但是大量用户去同一个地方拉取，服务器压力很大，用户分布全球，如从一个地方下载，时延较长，需要有分发网络。分发网络分为 中心和边缘两层。边缘层服务器部署在全国各地横跨各大运营商里，和用户距离近。中心层流媒体服务集群，负责内容的转发。智能负载均衡系统，根据用户的地理位置信息，就近选择边缘服务器，也负责转码服务，例如把RTMP协议的码流转换为HLS码流。
<br>


拉流  

![](https://github.com/MA806P/ComputerScienceNotes/blob/master/ComputerNetwork/Images/6-Application-GetVideo.jpg)   

先读到的是 H.264 的解码参数，例如 SPS  PPS ，然后对收到的 NALU 组成的一个个帧，进行解码，交给播放器播放。
<br>

小结：
* 视频名词较多，编码两大流派达成一致，通过时间、空间各种算法压缩数据；
* 压缩好的数据，为了传输组成一系列 NALU 按照帧和片依次排列；
* 排列好的 NALU 正在网络传输时，按照 RTMP 包的格式进行包装，RTMP 的包会拆分成 Chunk 进行传输
* 推送到流媒体集群的视频流经过转码和分发，可以被客户端通过该过 RTMP 协议拉取，然后组合为 NALU，解码成视频格式进行播放。
<br>


### 十七：P2P协议
下载电影的方式：  
* HTTP 进行下载，通过浏览器下载，下载速度慢   
* FTP 文件传输协议。采用两个 TCP 连接来传输一个文件：控制连接、数据连接。。两种工作模式：主动模式、被动模式。
* P2P
<br>

P2P  
HTTP FTP 这两种方式下载，都难以解决单一服务器的带宽压力。

种子文件，.torrent文件两部分组成：announce(tracker URL)和文件信息。  
文件信息：info区、Name字段、每段大小、段哈希值。  
BT 客户端首先解析.torrent 文件，得到 tracker 地址，然后连接 tracker 服务器。tracker 服务器回应下载者的请求，将其他下载者（包括发布者）的 IP 提供给下载者。下载者再连接其他下载者，根据.torrent 文件，两者分别对方告知自己已经有的块，然后交换对方没有的数据。此时不需要其他服务器参与，并分散了单个线路上的数据流量，因此减轻了服务器的负担。
弊端：一旦 tracker 服务器出现故障或者线路遭到屏蔽，BT 工具就无法正常工作。   

去中心化网路 DHT: Distribute Hash Table  
每个加入这个 DHT 网路的人，都要负责存储这个网路的资源信息和其他成员的联系信息，相当于所有人一起构成了一个庞大的分布式存储数据库。  
DHT 协议，Kademlia 协议，和区块链的概念一样。复杂
<br>
小结：
* 下载文件可以使用 HTTP 或 FTP，这两种是集中下载的方式，P2P采用非中心化下载的方式。
* P2P有两种，一种是依赖 tracker 的，也即元数据集中，文件数据分散；另一种是分布式的哈希算法，元数据和文件数据全部分散。
<br>


### 十八、DNS协议
DNS 服务器，IP 地址簿。DNS很重要，每人上网都需要它，一旦出故障，整个互联网都将瘫痪。
DNS 服务器一定要设置成高可用、高并发和分布式的。树状的层次结构。根DNS(返回能解析.com .cn .net ...的DNS服务器地址)、顶级域DNS(返回能解析163.com ..的DNS服务器地址)、权威DNS(返回域名IP地址)。   

DNS 解析流程   
负载均衡。DNS除了可以通过名称映射IP地址，还可以做负载均衡，应用可能部署在多个机房，每个地方都有自己的IP地址，当用户访问某个域名时，这个IP地址可以轮询访问多个数据中心。
<br>
小结：
* DNS 是网络世界的地址簿，可以通过域名查地址，因为域名服务器是按照树状结构组织的，因而域名查找是使用递归的方法，并通过缓存的方式增强性能； 
* 在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。
<br>

### 十九、HTTPDNS  
传统 DNS 存在一些问题：域名缓存问题、域名转发问题、出口 NAT 问题、域名更新问题、解析延迟问题。   

HTTPDNS 的工作模式：  
HTTPNDS 其实就是，不走传统的 DNS 解析，而是自己搭建基于 HTTP 协议的 DNS 服务器集群，分布在多个地点和多个运营商。当客户端需要 DNS 解析的时候，直接通过 HTTP 协议进行请求这个服务器集群，得到就近的地址。   
一是解析速度和更新速度的平衡问题，二是智能调度的问题，对应的解决方案是 HTTPDNS 的缓存设计和调度设计。
<br>
小结：
* 传统的 DNS 有很多问题，例如解析慢、更新不及时。因为缓存、转发、NAT 问题导致客户端误会自己所在的位置和运营商，从而影响流量的调度。 
* HTTPDNS 通过客户端 SDK 和服务端，通过 HTTP 直接调用解析 DNS 的方式，绕过了传统 DNS 的这些缺点，实现了智能的调度。  

<br>


### 二十、CDN  
CDN 的分发系统的架构
CDN 系统的缓存，也是一层一层的，能不访问后端真正的源，就不打扰它。  

* CDN 和电商系统的分布式仓储系统一样，分为中心节点、区域节点、边缘节点，而数据缓存在离用户最近的位置。   
* CDN 最擅长的是缓存静态数据，除此之外还可以缓存流媒体数据，这时候要注意使用防盗链。它也支持动态数据的缓存，一种是边缘计算的生鲜超市模式，另一种是链路优化的冷链运输模式。
<br>

### 二十一、数据中心

* 数据中心分为三层。服务器连接到接入层，然后是汇聚层，再然后是核心层，最外面是边界路由器和安全设备。 
* 数据中心的所有链路都需要高可用性。服务器需要绑定网卡，交换机需要堆叠，三层设备可以通过等价路由，二层设备可以通过 TRILL 协议。 
* 随着云和大数据的发展，东西流量相对于南北流量越来越重要，因而演化为叶脊网络结构。
<br>

### 二十二、VPN  
VPN（Virtual Private Network）虚拟专用网，利用开放的公众网络，建立专用数据传输通道，将远程的分支机构、移动办公人员等连接起来。  
VPN 三种协议：乘客协议、隧道协议和承载协议。   
IPsec VPN，基于 IP 协议的安全隧道协议，采取了一定的机制保证安全性：私密性、完整性、真实性。预共享密钥，用数字签名来验证。   

基于以上三个特性，组成了 IPsec VPN 的协议簇。  
协议簇里有两种协议，区别在于封装网络包的格式不一样。AH Authentication Header，只能进行数据摘要，不能实现数据加密。ESP Encapsulating Security Payload 只能进行数据加密和数据摘要。  
协议簇里还有两类算法，加密算法和摘要算法。两大组件，堆成密钥交换的 IKE 组件，对连接进行维护的SA Security Association 组件。  

IPsec VPN 的建立过程  
1、建立 IKE 自己的 SA ，维护一个通过身份认证和安全保护的通道，为第二阶段提供服务, DH 算法算出一个对称密钥 K。  
2、建立 IPsec SA。在这个 SA 里面，双方会生成一个随机的对称密钥 M ，由 K 加密传给对方，然后使用 M 进行双方接下来通信的数据  

IPsec SA 里面的内容：SPI security parameter index，用于标识不同的连接；双方商量好的加密算法、哈希算法和封装模式；生存周期，超过这个周期，就需要重新生存一个 IPsec SA，重新生成对称密钥。  

IPsec 建立好，接下来就可以开始打包封装传输了。
ESP 对 IP 包进行封装，IP 头里的上层协议为 ESP，在ESP正文里面 头部有双方商讨好的 SPI，以及这次传输的序列号。然后进行加密。  
这种点对点的基于 IP 的 VPN，能满足互通的要求，但是速度较慢，这是由底层 IP 协议的特性决定的，IP 不是面向连接的，是尽力而为的协议，每个 IP 包自由选择路径，到每一个路由器，都自己去找下一跳，丢了就丢了，是靠上一层TCP的重发来保证可靠性。  
因为 IP 网络从设计的时候，就是认为不可靠的，所以即使同一个连接，也可能选择不同的道路，好处 一条道路崩溃的时候 其他的路可以走。代价就是不断的路由查找，效率较差。   
和 IP 对应的技术成为 ATM 它是面向连接的。 ATM 和 TCP 不在同一层，和 IP在同一层。  
TCP 所谓的面向连接，是不停重试来保证成功，其实下层IP还是不面向连接的。ATM 是传输之前先建立一个连接形成一个虚拟的通路，一旦连接建立了，所有的包都按照相同的路径走，不会分头行事。不需要每次都查找路由表，虚拟路径已经建立了，打上了标签，后续的跟着走就行。  


一种结合 IP ATM 两者的优点，多协议标签交换(MPLS，Multi-Protocol)。  
一个通过标签转换而建立的路径称为 LSP，标签转换路径。  
生成标签 LDP(Label Distribution Protocol) 动态的生成标签的协议。  
如果 VPN 通道里包的转发，都是通过标签的方式进行，效率就会高很多。  
<br>

小结：  
* VPN 可以将一个机构的多个数据中心通过隧道的方式连接起来，让机构感觉在一个数据中心里面，就像自驾游通过琼州海峡一样；   
* 完全基于软件的 IPsec VPN 可以保证私密性、完整性、真实性、简单便宜，但是性能稍微差一些；   
* MPLS-VPN 综合和 IP 转发模式和 ATM 的标签转发模式的优势，性能较好，但是需要从运营商购买
<br>


### 二十三、移动网络  
2G 3G 4G 
基站子系统，一部分对外提供无线通信，叫作基站收发信台 BTS Base Transceiver Station，另一部分对内连接有线网络，叫作基站控制器 BSC Base Station Controller。          

2G 时代的上网几个核心点：  
* 手机通过无线信号连接基站；  
* 基站一面朝前接无线，一面朝后接核心网；  
* 核心网一面朝前接到基站请求，一是判断你是否合法，二是判断你是不是本地号，还有没有钱，一面通过网关连接电话网络。  

2G 到了 2.5G，也即在原来电路交换的基础上，加入了分组交换业务，支持 Packet 的转发，从而支持 IP 网络。  
3G 时代，主要是无线通信技术有了改进，大大增加了无线的带宽。  

4G 网络，基站为 eNodeB，包含了原来 Node B 和 RNC 的功能，下行速度向百兆级别迈进。MME 是核心控制网元，是控制面的核心，当手机通过 eNodeB 连上的时候，MME 会根据 HSS 的信息，判断你是否合法。  
<br>
控制面协议：  
eNodeB 和 MME 之间的连接就是很正常的 IP 网络，但是这里面在 IP 层之上，却既不是 TCP，也不是 UDP，而是 SCTP。这也是传输层的协议，也是面向连接的，但是更加适合移动网络。  
SCTP特点： 多宿主、将一个联合分成多个流、四次握手防止SYN攻击、将消息分帧、断开连接是三次挥手。  
当 MME 通过认证鉴权，同意这个手机上网，需要建立一个数据面的数据通路。建立通路的过程使用的是控制面的协议 GTP-C。  

数据面协议  
<br>
小结：  

* 移动网络的发展历程从 2G 到 3G，再到 4G，逐渐从打电话的功能为主，向上网的功能为主转变；  
* 请记住 4G 网络的结构，有 eNodeB、MME、SGW、PGW 等，分控制面协议和数据面协议；  
* 即便你在国外的运营商下上网，也是要通过国内运营商控制的，因而也上不了脸书。  














