
### 十四、HTTP 协议
http://www.163.com 是个 URL 叫做统一资源定位符。  

一、HTTP 请求的准备   
浏览器会将域名发送给 DNS 服务器，让它解析为 IP 地址。 然后建立 TCP 连接。目前使用的 HTTP 协议大部分是 1.1，在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样建立的 TCP 连接，就可以在多次请求中复用。   
<br>

二、HTTP 请求的构建   
建立了连接后，浏览器就要发送 HTTP 的请求。  
HTTP 的请求报文大概分为三大部分。请求行、首部、正文实体。  
<br>
请求行： 方法 sp URL sp 版本 cr If  
对于访问网页，常用类型是 GET 去服务器获取一些资源。  
POST 类型，需要主动告诉服务端一些信息。  
PUT 类型，向指定资源位置上传最新内容。HTTP 的服务器往往是不允许上传文件的，所以 PUT 和 POST 都变成了要传给服务器东西的方法。实际使用中两者还有些区别。POST 往往是用来创建一个资源，PUT 往往是用来修改一个资源的。  
DELETE 类型，用来删除资源的。例如要删除一个云主机，就会调用 DELETE 方法。
<br>
首部字段：key value，通过冒号分隔。  
Accept-Charset 表示客户端可以接受的字符集。防止传来的是另外的字符集，从而导致出现乱码。  
Content-Type 正文的格式。例如我们进行 POST 请求如果正文是 JSON，就应该将这个值设置为 JSON。  
缓存  
<br>
![](https://github.com/MA806P/ComputerScienceNotes/blob/master/ComputerNetwork/Images/6-Application-WebCache.jpg)
<br>
Nginx 这一层：对于静态资源，有 Varnish 缓存层，当缓存过期的时候，才会访问真正的 Tomcat 应用集群。  
Cache-control 是用来控制缓存的。当客户端发送的请求中包含 max-age 指令时，如果判定缓存层中，资源的缓存时间数值比指定的时间的数值小，那么客户端可以接受缓存的资源；当指定 max-age 值为0，那么缓存层通常需要将请求转发给应用集群。  
If-Modified-Since 这个也是一个关于缓存的，如果服务器的资源在某时间之后更新了，那么客户端就应该下载最新资源。如果没有更新，服务端会返回 304 not modified 的响应，客户端就不用下载了，也会节省宽带。  
<br>
HTTP 的请求报文确定好了之后，浏览器会把它交给下一层传输层，Socket 处理。 
<br>

三、HTTP 请求的发送  
HTTP 协议是基于 TCP 协议的，使用面向连接的方式发送请求，通过 stream 二进制流的方式传给对方。  
在发送给每个报文段的时候，都需要对方有一个回应 ACK ，来保证报文可靠到达对方。HTTP 不需要关系这些，TCP 来处理。TCP 层发送每一个报文的时候，都需要加上自己地址源地址和目标地址，将信息放到IP头里，交给IP层进行传输。  
IP 层查看目标地址和自己是否在同一个局域网。如果是，发送 ARP 协议来请求这个目标地址对应的 MAC 地址，然后将源和目标 MAC 放入 MAC 头，发送出去即可。如果不在同一个局域网，就需要发送到网关，ARP 协议获取网关的 MAC 地址，放入 MAC 中发送出去。  
网关收到包 MAC 符合，取出目标 IP 地址，根据路由协议找到下一跳路由器，获取下一跳路由器 MAC 地址，将包发送给下一跳路由器，最终到达目标局域网。最后一跳路由器发现目标地址就在自己的某一个出口的局域网上，在局域网上发送 ARP 获取目标地址的 MAC 地址，将包发出去。目标机器发现 MAC 地址符合，把包收起来，发现 IP 地址符合，根据 IP 头中协议项，知道自己上一层是 TCP 协议，解析 TCP 头，确认这个序列包是不是我要的，如果是放入缓存中然后返回一个 ACK ，如果不是就丢弃。

TCP 头里有端口号，HTTP 服务器正在监听这个端口号，目标机器知道 HTTP 服务器这个进程想要这个包，将包发送给它。HTTP 服务器的进程看到，请求是要访问一个网页，就把这个网页发给客户端。
<br>

四、HTTP 返回的构建  
返回的报文也是有一定格式的。  
状态码会反应 HTTP 请求的结果。 返回首部的 key value。  
Retry-After 表示，告诉客户端应该在多长时间后再次尝试。503 错误 服务器暂时不再和这个配合使用。  
Content-Type: HTML  JSON。  
构造好返回的 HTTP 报文，交给 Socket 发送，交给 TCP 层，TCP 层将返回的 HTML，也分成一个个小段，保证每段都可靠到达。当浏览器拿到 HTTP 的报文返回 200，一切正常，从正文中拿出 HTML，浏览器根据 HTML 格式展示网页。
<br>


五、HTTP 2.0  
1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 头，不考虑 pipeline 模式的话，每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题。  
2.0 为对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key value 在两端建立一个索引表，对相同的头只发送索引表中的索引。  
2.0 协议将一个 TCP 的连接中，切分成多个流，每个流都有自己的 ID，可相互发送 s->c c->s，其实只是一个虚拟的通道。流是有优先级的。  
2.0 还将所有的传输信息分割为更小的消息和帧，并采用二进制格式编码。常见的 Header 帧，用于传输 Header 内容，并且会开启一个新的流。Data 帧，用来传输正文实体。多个 Data 帧属于同一个流。  
这两种机制，2.0 的客户端可以将多个请求分到不同流中，将请求内容拆分成帧，进行二进制传输。这些帧可以乱序发送，然后根据每个帧首部流标识符组装，可以根据优先级优先处理哪个流的数据。   
举例，假设一个页面要发送三个独立的请求，获取 css js jpg，2.0 中实际是将三个请求变成三个流，将数据分成帧，乱序发送到一个 TCP 连接中，加快页面组件的传输速度。解决了 1.1 的队首拥塞问题，同时也不需要 1.X 的 pipeline 机制用多条 TCP 连接来实现并行请求与响应，减少 TCP 连接数对服务器性能的影响。  
<br>

六、QUIC 协议  
2.0 虽然大大增加了并发性，但还是有问题的。2.0是基于 TCP 协议的，TCP 协议在处理包时是有严格顺序的。当其中一个数据包遇到问题，TCP 连接需要等待这个包完成重传后才能继续进行。虽然 2.0 通过多个 stream 使得逻辑上一个 TCP 连接上的并行内容，进行多路数据的传输，这中间没有关联的数据。stream2的帧没收到，stream1的帧也会因此阻塞。  
<br>
QUIC:
机制一：定义连接机制  
一条 TCP 连接是由四元组标识的，源IP，源端口、目的IP、目的端口。一旦一个元素发生变化时，就需要断开重连。  
但是基于 UDP 就可以在 QUIC 自己的逻辑里面维护连接的机制，不再以四元组标识，而是以一个 64位随机数作为 ID来标识，只要 ID 不变，就不需要重新建立连接。  
机制二：自定义重传机制  
QUIC 序列号是递增的，任一个序列号的包只发一次，下次就要加一。QUIC 面向连接的，像 TCP 一样，是个数据流，发送的数据在这个数据流里有个偏移量 offset，可以查看数据发送到哪里，只要这个 offset 的包没来，就要重发，按照offset拼接，拼成一个流。  
机制三：无阻塞的多路复用  
同 2.0 一样，同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求。但是 QUIC 是基于 UDP 的，一个连接上的多个 steam 之间没有依赖。stream2丢了一个UDP包，需要重传，但是后面的stream3的包无需等待就可以发给用户。  
机制四：自定义流量控制  
TCP 的流量控制是通过滑动窗口协议。QUIC的流量控制也是通过 window_update 来告诉对端可以接受的字节数。但QUIC的窗口是适应自己的多路复用机制，不但在一个连接上控制窗口，还在一个连接中的每个 stream 控制窗口。

<br>
小结：  
1、HTTP 有 get post put delete 这几个方法。首部字段。  
2、HTTP 2.0 通过头压缩、分帧、二进制编码、多路复用等技术提升性能。  
3、QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进一步提升性能。
<br>


### 十五、HTTPS  
加密分为两种方式，对称加密、非对称加密  
一、对称加密  
对称加密算法中，加密和解密使用的密钥是相同的。  
对称加密算法要保证安全的话，密钥要做好保密，只能让使用的人知道，不能对外公开。  

<br>
二、非对称加密  
非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。  
一把公开的公钥，另一把私钥。公钥加密的信息只有私钥才能解密。私钥加密的信息，只有公钥才能解密。  
一对公钥私钥是不够的，客户端、服务端都要有自己的公钥私钥。  
客户端给购物网站发送的时候，用购物网站的公钥加密。网站给客户端发送消息的时候，使用客户端的公钥。这样就算中途被截获信息，没有私钥解不开。

<br>
三、数字证书  
不对称加密，如何将公钥给对方呢。一种是放在公网的地址上，让对方下载。另一种是在建立连接的时候，传给对方。  
怎么鉴别给你的公钥是对的，毕竟每个人都是可以创建自己的公钥和私钥。
```
//创建私钥
openssl genrsa -out cliu8siteprivate.key 1024

//创建公钥
openssl rsa -in cliu8siteprivate.key -pubout -outcliu8sitepublic.pem
```
证明身份，需要有权威部门颁发的证书。证书里有公钥、证书的所有者、发布机构、证书的有效期。  
生成证书需要发起证书请求，发给一个权威机构去认证，这个机构我们称为 CA ( Certificate Authority)
```
证书请求：
openssl req -key cliu8siteprivate.key -new -out cliu8sitecertificate.req
```
将这个请求发给权威机构，会给这个证书卡一个章，称为 签名算法。只有用只掌握在权威机构手里的东西签名了才行，这就是 CA 的私钥。  

签名算法：一般是对信息做一个 Hash 计算，得到一个 Hash 值，这个过程不可逆，无法通过 Hash 值得出原来的信息内容。在把这个信息发出去时，把这个 Hash 值加密后，作为一个签名和信息一起发出去。  
```
CA 给证书签名的命令：
openssl x509 -req -in cliu8sitecertificate.req -CA cacertificate.pem -CAkey caprivate.key -out cliu8sitecertificate.pem
//返回 Signature ok， cliu8sitecertificate.pem 就是签过名的证书
//CA 用自己的私钥给网站的公钥签名，就相当于给网站背书，形成网站的证书

查看证书内容：
openssl x509 -in cliu8sitecertificate.pem -noout -text 
// lssuer: 证书是谁颁发的
// Subject: 证书颁发给谁
// Validity: 证书期限
// Public-key: 公钥内容
// Signature Algorithm: 签名算法
```  
你不会从网站上得到一个公钥，而是会得到一个证书，证书有发布机构 CA ，得到这个 CA 的公钥，去解密网站证书的签名，解密成功，Hash 也对的上，就说明这个网站的公钥没问题。  
要想验证证书，需要 CA 的公钥，怎么确定 CA 的公钥是对的呢？  
CA 公钥也需要更牛的 CA 给它签名，然后形成 CA 的证书。要想知道某个 CA 的证书是否可靠，要看 CA 的上级证书的公钥，能不能解开这个 CA 签名。层层验证，知道全球皆知的几个著名大 CA ，root CA，这种层层授信背书的方式，保证非对称加密的正常运转。   

还有一种证书，Self-Signed Certificate，自己给自己签名，我就是我 爱信不信。哈哈哈


<br>
四、HTTPS 的工作模式  
HTTPS 协议的思路，将非对称和对称加密结合起来。公钥私钥主要用于对称加密的密钥，而真正的双方大数据量的通信都是通过对称加密进行的。  

当登陆购物网站时，由于是 HTTPS ，客户端会发送 Client Hello 消息到服务器，以明文传输 TLS 版本信息、加密套件候选列表、压缩算法候选列表等信息。另外，还会有个随机数，在协商对称密钥的时候使用。  

然后，网站返回 Server Hello 消息，告诉客户端，服务器选择使用的协议版本、加密套件、压缩算法等，还有随机数，用于后续的密钥协商。  

然后，网站会给你一个服务器端的证书。  

然后，客户端验证这个证书，从客户端自己信任的 CA 仓库中，拿 CA 证书里面的公钥去解密网站的证书。可能会不断往上追溯 CA 的 CA，直到一个授信的 CA。验证完毕后，网站可信，客户端计算产生随机数字 Pre-master, 发送 Client key Exchange，用证书中的公钥加密，在发送给服务器，服务器可以通过私钥解密出来。
然后，C S，都有三个随机数：自己的、对端、刚生成的 Pre-Master。通过这三个随机数，可以在 C S 产生相同的对称密钥。   

有了对称密钥，客户端，发送一个 Encrypted Handshake Message, 将已经商量好的参数等，采用协商密钥进行加密，发送给服务器用于数据与握手验证。服务器也发送 Encrypted Handshake Message 的消息试试。当双方握手结束后，就可以通过对称密钥进行加密传输了。  

这个过程除了加密解密之外，其他的过程和 HTTP 是一样的。
这只包含了 HTTPS 的单向认证 客户端验证服务端的证书，也可在更加严格安全要求的情况下，启用双向认证，双方互相验证证书。  

<br>
五、重放与篡改  
有了加密解密，截获的包也打不开了，但是它可以发送N次，通过 Timestamp 和 Nonce 随机数联合起来，然后做一个不可逆的签名来保证。  
Nonce 随机数保证唯一，或者 Timestamp 和 Nonce 合起来保证唯一，同样的请求只接受一次，多次则视为无效。  
如果有人想篡改 Timestamp 和 Nonce ，还有签名不可篡改性，如果改了用签名算法解出来，就对不上了，可丢弃。

<br>
小结：
* 对称加密效率高，解决不了密钥传输问题；非对称加密可解决，但是效率不高。
* 非对称加密需要通过证书和权威机构来验证公钥的合法性。
* HTTPS 综合了对称和非对称加密算法的 HTTP 协议。既保证传输安全，也保证传输效率。





