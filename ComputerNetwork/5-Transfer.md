

### 十、UDP协议

传输层比较重要的两个协议，TCP、UDP
区别：
1、TCP 是面向连接的，UDP 是面向无连接的。所谓建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。
2、TCP 提供可靠交付，通过TCP连接传输的数据，无差错、不丢失、不重复、并且按顺序到达。IP包是没有任何可靠性保证的，UDP继承了IP包的特性，不保证不丢失，不保证按顺序到达。
3、TCP是面向字节流的，发送的时候发的是一个流，没头没尾，IP包是一个个的IP包，UDP继承了IP的特性，基于数据报的，一个一个的发收。
4、TCP可以有拥塞控制的。UDP就不会。
5、TCP其实是一个有状态服务，有脑子的。UDP没有，发出去就发了。

网络传输是以包为单位，二层叫帧，网络层叫包，传输层叫段。我们笼统地称为包。包单独传输，自行选路，在不同的设备封装解封装，不保证到达。
UDP包头：
当发送的UDP包到达目标机器后，发现MAC地址匹配，就取下来，将剩下的包传给处理IP层的代码，把IP头取下来，发现目标IP匹配，进行处理，IP头里有个8位协议说明数据里面是TCP还是UDP，知道UDP头的格式，就能解析数据。
无论TCP还是UDP包头里应该有端口号，根据端口号，将数据交给相应的应用程序。
源端口号16位  目的端口号16位  UDP长度16位  UDP校验和16位  数据

UDP三大特点：沟通简单 轻信他人 不懂权变
UDP三大使用场景：
1、需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用
2、不需要一对一沟通，建立连接，而是可以广播的应用
3、需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候

QUIC（全称Quick UDP Internet Connections，快速 UDP 互联网连接）是 Google 提出的一种基于 UDP 改进的通信协议，其目的是降低网络通信协议，其目的是降低网络通信的延迟，提供更好的用户互动体验。
流媒体的协议
实时游戏
IoT 物联网
移动通信领域

小结：
1、如果将 TCP 比作成熟的社会人，UDP 则是头脑简单的小朋友。TCP 复杂，UDP 简单；TCP 维护连接，UDP 谁都相信；TCP 会坚持知进退；UDP 愣头青一个，勇往直前
2、UDP 虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。例如 DHCP、VXLAN、、QUIC 等。



### 十一、TCP 协议（上）

TCP 包头格式，比 UDP 复杂的多。
源端口号16位  目的端口号16位  序号32位  确认序号32位  首部长度4位  保留位6位
URG ACK PSH RST SYN FIN   窗口大小16位  校验和16位 紧急指针16位 选项 数据
1、端口号，可知道应该发给哪个应用
2、序号，为了解决乱序的问题，确认哪个先来，哪个后到
3、确认序号，发出的包应有确认，没收到重新发，直到送达，
4、状态位。SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接等。TCP面向连接的，双方要维护连接的状态，带状态位的包发送，会引起双方的状态变更。
5、窗口大小。TCP要做流量控制，窗口标识自己当前能够处理能力
顺序问题，稳重不乱
丢包问题，承诺靠谱
连接维护，有始有终
流量控制，把我分寸
拥塞控制，知进知退


<br>

TCP 三次握手：请求 - 应答 - 应答之应答
为何是三次，两次不靠谱，三次只是最优的办法，严格来说三十次都不能确定

三次握手除了双方建立连接外，主要还是为了沟通 TCP包的序号问题，A B 互相告诉，我这面发起的包的序号起始是从哪个号开始的
每个链接都要有不同的序号，随着时间变化，可看成32位计数器，每 4ms +1，IP 包头里有个 TTL 生存时间。
双方建立了信任，建立了链接，需要维护一个状态机。

![](https://github.com/MA806P/ComputerScienceNotes/blob/master/ComputerNetwork/Images/5-Transfer-Connect.jpg)

<br>

TCP 四次挥手

![](https://github.com/MA806P/ComputerScienceNotes/blob/master/ComputerNetwork/Images/5-Transfer-Disconnect.jpg)

断开的时候，当 A 说不玩了，就进入 FIN_WAIT_1 的状态，B 收到消息后，发送知道了。就进入 CLOSE_WAIT 的状态。
A 收到 ”B说知道了“ 就进入 FIN_WAIT_2 的状态。
如果B这时直接跑了，A将永远在这个状态，TCP协议没对这个状态处理，但Linux可以调整tcp_fin_timeout参数设置一个超时时间。
如果B没跑，发送了”B也不玩了“到A，A发送”知道B不玩了“的ACK后，从FIN_WAIT_2状态结束，为了防止最后的ACK B收不到，B要是收不到B会重新发一个”B不玩了“，为了防止这中情况，TCP协议要求A最后等待一段时间TIME_WAIT,这个时间要足够长，长到B没收到ACK的话，”B说不玩了“重发。
A不等待直接跑了，还有一个问题，A的端口就空出来了，但是B不知道，B还有很多包，可能还在路上，如A的端口被一个新的应用占用了，这个新的应用会收到B的发来的包，虽然序列号是重新生成的，但也要上个双保险防止产生混乱，因而也要等足够长的时间，等B的包都结束生命，再空出端口出来。

等待时间设置为 2MSL，Maximum Segment LifeTime 报文最大生存时间，是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。TCP报文是基于 IP 协议的，IP头中有 TTL 域，是IP数据报可以经过的最大路由数，每经过一个路由器此值-1，当为0就丢弃，同时发送ICMP报文通知源主机。协议规定 MSL 为 2分钟，实际常用的 30s,1分钟，2分钟。

如果B超过2MSL依然没有收到A发的FIN的ACK，怎么办，当然B会重发FIN，A已经等了足够长的时间已跑了，A收到B重发的包后，直接发送RST，B就知道A早跑了。

<br>

TCP 状态机

![](https://github.com/MA806P/ComputerScienceNotes/blob/master/ComputerNetwork/Images/5-Transfer-status.jpg)

<br>

小结
1、TCP包头复杂，主要关注五个问题，顺序问题、丢包问题、连接维护、流量控制、拥塞控制
2、三次握手  四次挥手

如何在系统中查看某个连接的状态？
连接维护问题解决了。用什么数据结构来处理其他的四个问题




### 十一、TCP 协议（下）
出了网关，要保证传输的可靠性，需要各种重传的策略，包含大量的算法。

如何做个靠谱的人？
客户端发送一个包，服务器端应该有个回复，如果超时未回复，客户端重新发送
上一个收到了应答，再发送下一个。效率比较低。
可先将事情记录下来，办完一件回复一件。在处理事件的过程中可以向他交代新的事情，这样双方就能并行了。
事件多了就需要给每个事情编号，防止弄错。

如何实现一个靠谱的协议？
TCP 协议，为了保证顺序性，每个包都有一个 ID，建立连接的时候，商议起始的 ID 是什么，然后按照 ID 一个个发送，为了保证不丢包，对于发送的包都要进行应答，应答不是一个个来的，会应答某个之前的 ID，表示都收到了，这种模式称为累计确认或者累计应答。

